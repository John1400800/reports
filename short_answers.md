# Ответы на Вопросы по Алгоритмизации и Программированию (Ужатая версия)

## Тема 16: Списки

### 1. Статические vs. Динамические величины:

*   **Статические:** Размер фиксируется **на этапе компиляции** (массивы).
*   **Динамические:** Размер меняется во время выполнения (списки, `std::vector`).

### 2. Указатель vs. Ссылка:

*   **Указатель:** Хранит адрес **объекта**, можно менять (**адрес, на который указывает**), может быть `nullptr` (**в C++11 и новее**), разыменование `*`. **Нуждается в явном разыменовании для доступа к значению.**
*   **Ссылка:** Псевдоним **существующего объекта**, не меняется (**после инициализации всегда ссылается на один и тот же объект**), не может быть `nullptr`, **автоматическое разыменование**. **Должна быть инициализирована при объявлении.**

### 3. Виды указателей:

*   Обычные, void, на функции, константные (**указатель на константу, константный указатель**), на указатели, умные (`std::unique_ptr`, `std::shared_ptr`, `std::weak_ptr`).

### 4. Адрес переменной:

*   Оператор `&`, возвращает адрес в памяти **переменной**.

### 5. Выделение/освобождение памяти:

*   C/C++: `malloc`/`free`, `new`/`delete`, **`new[]`/`delete[]` для массивов**.
*   Java/Python: Автоматически (сборщик мусора). **C++ также имеет автоматическое управление памятью через RAII (Resource Acquisition Is Initialization), часто используемое с умными указателями.**

### 6. Разыменование:

*   Операция `*`, получение значения **объекта** по адресу указателя.

### 7. "Мусор" в динамической памяти:

*   Утечка из-за забытого `free`/`delete` **(в C++)** или потери указателя на выделенную память. **Приводит к нехватке ресурсов и потенциальным сбоям.**

### 8. Связанный список:

*   Последовательность узлов, каждый хранит данные и указатель на следующий **узел**.

### 9. Классификация связанных списков:

*   Односвязные, двусвязные, многосвязные.
*   Линейные, кольцевые.
*   Несортированные, отсортированные.
*   С/без головного узла **(фиктивного узла для упрощения операций)**.

### 10. Действия над списками:

*   Создание, добавление (в начало, конец, середину), удаление (по значению, индексу, узлу), поиск, просмотр, получение длины, очистка, разворот, слияние, сортировка.

### 11. Описание списка (C++):

*   `struct Node { DataType data; Node* next; };` **(где `DataType` - тип данных)**
*   `class LinkedList { Node* head; public: /*методы*/ };` **(указываем секцию public для доступа к методам)**

### 12. Стек, очередь:

*   **Стек:** LIFO (Last-In, First-Out). Операции: `push`, `pop`, `peek` (**top**).
*   **Очередь:** FIFO (First-In, First-Out). Операции: `enqueue` (**push, add**), `dequeue` (**pop, remove**), `peek` (**front**).

### 13. Операции над стеком:

*   `push` (добавить элемент на вершину), `pop` (удалить верхний элемент), `peek` (**top**) (посмотреть верхний элемент без удаления), `isEmpty`, **`isFull` (при реализации на массиве)**, `size`, `clear`.

### 14. Операции над очередью:

*   `enqueue` (добавить элемент в конец), `dequeue` (удалить элемент из начала), `peek` (**front**) (посмотреть элемент в начале без удаления), `isEmpty`, **`isFull` (при реализации на массиве с фиксированным размером)**, `size`, `clear`.

## Тема 17: Деревья

### 1. Дерево:

*   Иерархическая структура: корень, родитель, потомок, лист, **ветвь, уровень**.

### 2. Классификация деревьев (см. полную версию)** **(Примеры: бинарные деревья поиска, AVL-деревья, красно-черные деревья, B-деревья)**

### 3. Бинарное дерево:

*   У каждого узла не более 2 потомков (левый, правый).

### 4. Узел, потомок, предок, листья, корень:

*   Узел: элемент дерева.
*   Потомок: узел ниже по иерархии.
*   Предок: узел выше по иерархии.
*   Листья: узлы без потомков.
*   Корень: начальный узел.

### 5. Структура узла:

*   Данные, указатели на потомков (`left`, `right`), **указатель на `parent` (не всегда)**.

### 6. Обход дерева:

*   Прямой (корень, лево, право) **(preorder)**, симметричный (лево, корень, право) **(inorder)**, обратный (лево, право, корень) **(postorder)**.
*   Обход в ширину (по уровням) **(breadth-first search, BFS)**.

### 7. Динамические структуры данных:

*   Связный список, стек, очередь, дерево, граф, хэш-таблица, куча **(например, бинарная куча)**, **трие (префиксное дерево)**.

### 8. Преимущество дерева перед списком:

*   Более эффективный поиск/вставка/удаление **в отсортированных деревьях** (в среднем логарифмическая сложность).
*   Подходит для иерархических данных.

## Тема 18: Вектор

### 1. STL:

*   Стандартная библиотека шаблонов C++, контейнеры, итераторы, алгоритмы, **функциональные объекты (функторы)**.

### 2. Разновидности коллекций (см. полную версию)** **(Примеры: последовательные, ассоциативные, контейнерные адаптеры)**

### 3. Вектор (std::vector):

*   Динамический массив, быстрый доступ по индексу, автоматическое управление памятью, **эффективное добавление в конец**.

### 4. Описание вектора:

*   `std::vector<DataType> vectorName;`

### 5. Особенности обработки векторов:

*   Динамическое управление памятью, индексация, добавление/удаление (в конце эффективно, в начале/середине - нет), обход, копирование.

### 6. Доступ к элементу вектора:

*   `[]` (без проверки границ, **потенциально небезопасно**), `at()` (с проверкой границ, **генерирует исключение `std::out_of_range`**), `front()`, `back()`.

### 7. Последовательные контейнеры:

*   `vector`, `deque`, `list`, `forward_list`, `array`.

### 8. Итератор:

*   Объект для доступа к элементам контейнера, перемещение по контейнеру, **обобщенный способ доступа**.

### 9. Итерируемый объект:

*   Объект, поддерживающий итерацию, **предоставляет методы `begin()` и `end()`**, возвращает итератор.

### 10. Обход вектора с итератором:

*   Цикл `for` с `begin()`, `end()`, `++it`, range-based `for` **(`for (auto& element : vectorName)`)**.

## Тема 19: Множества

### 1. Определение множества:

*   Неупорядоченная **(в `std::unordered_set`)** или упорядоченная **(в `std::set`)** коллекция уникальных элементов.

### 2. Описание множества (C++):

*   `std::set<DataType>`, `std::unordered_set<DataType>`.

### 3. Базовый тип множества:

*   Тип данных, хранящихся в множестве (`DataType`).

### 4. Допустимый базовый тип:

*   Примитивные типы, строки, пользовательские классы **(должен быть определен оператор `<` для `std::set`, операторы `==` и `std::hash` для `std::unordered_set`)**.

### 5. Мощность множества, пустое множество:

*   Мощность: количество элементов **(размер)**.
*   Пустое множество: нет элементов, мощность 0.

### 6. Доступ к элементам множества:

*   Через итераторы (`begin`, `end`), `find()` **(возвращает итератор или `end()`, если не найдено)**, `contains()` **(C++20)**.

### 7. Операции над множествами:

*   `insert`, `erase`, `find`, `contains`, `size`, `empty`, `clear`.
*   Объединение, пересечение, разность **(можно реализовать с помощью алгоритмов STL, таких как `std::set_union`, `std::set_intersection`, `std::set_difference`)**.

### 8. Способы помещения элементов в множество:

*   Инициализация **(например, через список инициализации `{1, 2, 3}`)**, `insert()`, `emplace()` **(строит объект непосредственно в множестве)**, конструктор копирования.

### 9. Вывод множества целиком:

*   Перебор с итераторами или range-based `for`.

### 10. Вывод элементов множества:

*   Цикл `for` с итераторами, range-based `for`, `std::for_each`.

### 11. Множество и дубликаты:

*   Не может содержать одинаковые элементы **(при попытке вставки дубликата, множество не изменяется)**.

### 12. Множество и разные типы:

*   В C++ - только один тип **(шаблонный параметр)**, в Python - может **(но это создает неоднородное множество)**.

## Тема 20: Модули

### 1. Модульное программирование:

*   Разделение на независимые модули, скрытие реализации **(инкапсуляция)**, **улучшение читаемости и поддерживаемости кода**.

### 2. Модуль:

*   Отдельная **логически завершенная** часть программы, выполняющая **определенную** функцию.

### 3. Логические части модуля:

*   Интерфейс (что **модуль предоставляет**), реализация (как **это достигается**).

### 4. Заголовочный файл (`.h`, `.hpp`), исходный код (`.cpp`):

*   `.h` **(C)** / `.hpp` **(C++)**: Интерфейс (объявления **классов, функций, констант, типов**).
*   `.cpp`: Реализация (определения **функций, методов классов**).

### 5. Подключение модулей:

*   Директива `#include` **(для вставки содержимого файла)** в начале файла. **`<filename>` для системных/библиотечных, `"filename"` для пользовательских.**

### 6. Сфера действия переменных:

*   Модуль: файловая (глобальная **в пределах одного файла**), `static` - только внутри модуля **(ограниченная видимость в пределах файла)**.
*   Функция: локальная (только внутри функции).

### 7. Разделы модуля (заголовочного файла):

*   Защита от многократного включения **(`#ifndef`, `#define`, `#endif` или `#pragma once`)**, объявления, **возможно inline-реализация (для простых функций)**.

### 8. Организация модуля (C/C++):

*   `.h`/`.hpp`: Интерфейс.
*   `.cpp`: Реализация.
*   Подключение `#include`, компиляция **каждого `.cpp` файла отдельно**, линковка **результатов компиляции в исполняемый файл**.

### 9. Сборка программы:

*   Препроцессирование **(обработка директив `#include`, макросов)**, компиляция **(преобразование исходного кода в объектный код)**, компоновка **(объединение объектных файлов и библиотек в исполняемый файл)**.

### 10. Библиотечные функции при сборке:

*   Статические библиотеки (`.lib` в Windows, `.a` в Linux): код копируется в исполняемый файл **на этапе линковки**.
*   Динамические библиотеки (`.dll` в Windows, `.so` в Linux): линкер добавляет информацию **о необходимости загрузки библиотеки**, загрузка при запуске **программы**.

## Тема 21: Классы C++

### 1. ООП:

*   Инкапсуляция, наследование, полиморфизм, абстракция. **(Также композиция)**

### 2. Расширения C++ относительно C:

*   ООП, шаблоны, ссылки, исключения, STL, **перегрузка операторов, пространства имен, RTTI (Run-Time Type Information)**.

### 3. Класс:

*   Шаблон объекта, инкапсуляция, абстракция.
*   Объект - конкретная **экземпляр** класса **в памяти**.

### 4. Сообщение (ООП):

*   Запрос от объекта к другому **объекту** (вызов метода).

### 5. Событийно-управляемая модель:

*   Программа реагирует на события (нажатия кнопок и т.п.). **(Примеры: GUI-приложения, веб-разработка)**

### 6. Интерфейс:

*   Правила взаимодействия, публичная часть класса **(методы и данные, доступные извне)**.

### 7. Поля и методы класса:

*   Поля **(члены-данные)**: данные, **состояние объекта**.
*   Методы **(член-функции)**: действия, **поведение объекта**.

### 8. Классы и структуры:

*   `struct`: **public** по умолчанию, **часто используются для простых агрегатов данных (POD - Plain Old Data)**.
*   `class`: **private** по умолчанию, **предназначены для представления объектов с инкапсуляцией поведения и данных**.

### 9. Инкапсуляция, наследование, полиморфизм:

*   **(см. полную версию)** **Кратко: Инкапсуляция - сокрытие внутреннего состояния и реализации, доступ через интерфейс. Наследование - создание новых классов на основе существующих, повторное использование кода. Полиморфизм - возможность обрабатывать объекты разных классов единообразно.**

### 10. Структура объявления класса:

*   `class ClassName { public: /*...*/ protected: /*...*/ private: /*...*/ };`

### 11. Обращение к компонентам класса:

*   Внутри: по имени.
*   Снаружи: `.` (объект), `->` (указатель).
*   `private` члены недоступны напрямую извне **класса**.

### 12. Инициализация объектов:

*   По умолчанию **(если не определен конструктор, или определен конструктор по умолчанию)**, конструктор **(основной способ)**, список инициализации **(для инициализации членов в конструкторе)**.

### 13. Наследование и модификаторы доступа:

*   `public`, `protected`, `private` наследование **(определяют уровень доступа к унаследованным членам в производном классе)**.

### 14. Спецификаторы доступа:

*   `private` (только внутри класса), `public` (везде), `protected` (внутри класса и в наследниках).

### 15. Set/Get функции:

*   `set` (мутаторы): установить значение **закрытого поля**, `get` (аксессоры): прочитать значение **закрытого поля**.

### 16. Конструктор:

*   Метод **с именем класса**, инициализации объекта. **Может быть несколько (перегрузка).**

### 17. Деструктор:

*   Метод **с именем класса, начинающимся с `~`**, освобождения ресурсов объекта **при его уничтожении**.

### 18. Объявление класса в отдельном файле:

*   `.h`/`.hpp`: объявление, `.cpp`: реализация **методов**.
*   `#include` в другом файле для использования **класса**.

### 19. `new` и память:

*   `new` размещает объект в динамической памяти **(в куче)**, **возвращает указатель на созданный объект**. **Требует `delete` для освобождения памяти.**

### 20. Вызов методов из других методов:

*   Прямой вызов, через `this` **(указатель на текущий объект)**, виртуальные методы **(для реализации полиморфизма)**.

### 21. Доступ к закрытым членам класса:

*   Только методы класса **(включая конструкторы и деструктор)** и дружественные классы/функции **(объявленные с ключевым словом `friend`)**.
