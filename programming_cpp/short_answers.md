# Ответы на Вопросы по Алгоритмизации и Программированию (Ужатая версия)

## Тема 1: Основы Алгоритмизации и Программирования

### 1. Что такое алгоритм?

*   **Алгоритм:** Чёткая последовательность **инструкций** для решения **определенной задачи** или достижения **конкретной цели**.

### 2. Перечислите свойства алгоритмов.

*   **Дискретность:** Разбит на **конечные шаги**.
*   **Детерминированность:** Каждый шаг **однозначен**, результат предсказуем.
*   **Конечность:**  Выполняется за **конечное время**.
*   **Результативность:** Приводит к **определенному результату**.
*   **Массовость:**  Применим к **разным исходным данным** одного типа.

### 3. Способы записи алгоритма.

*   **Словесный:** Описание **естественным языком**.
*   **Графический:** Блок-схемы.
*   **Псевдокод:**  Полуформализованное описание, **близкое к языку программирования**.
*   **Программный код:**  Запись на **языке программирования**.

### 4. Перечислите базовые алгоритмические конструкции. Какова блок-схема следования?

*   **Следование (последование):** Выполнение **команд последовательно**.
*   **Ветвление (выбор):**  Выполнение **одной из нескольких ветвей** в зависимости от условия.
*   **Цикл (повторение):**  Многократное выполнение **одного и того же блока кода**.

*   **Блок-схема следования:**  Прямоугольники, соединенные стрелками **сверху вниз**.

### 5. Какова блок-схема полной (неполной) формы команды ветвления?

*   **Полная форма:** Ромб (условие) с двумя выходами: "Да" (блок действий 1) и "Нет" (блок действий 2), оба сходятся далее.
*   **Неполная форма:** Ромб (условие) с двумя выходами: "Да" (блок действий) и "Нет" (выход без действий).

### 6. Какова блок-схема цикла с предусловием?

*   Ромб (условие) **перед** блоком действий. Если условие "Да", выполняется блок действий, затем возврат к проверке условия. Если "Нет", выход из цикла.

### 7. Какова блок-схема цикла с постусловием?

*   Блок действий **перед** ромбом (условие). После выполнения блока действий проверяется условие. Если "Да", возврат к блоку действий. Если "Нет", выход из цикла.

### 8. Какова блок-схема цикла с параметром?

*   Шестиугольник (начальное значение параметра, конечное значение, шаг), далее прямоугольник (блок действий), затем возврат к шестиугольнику для изменения параметра и проверки условия.

### 9. Что такое программа?

*   **Программа:** Алгоритм, записанный на **понятном компьютеру языке программирования**.

### 10. Что такое транслятор?

*   **Транслятор:** Программа, переводящая **исходный код** на одном языке программирования в **эквивалентный код** на другом языке.

### 11. Что такое компилятор?

*   **Компилятор:** Транслятор, преобразующий **весь исходный код** программы в **машинный код** (или объектный код) **единоразово**.

### 12. Что такое интерпретатор?

*   **Интерпретатор:** Транслятор, построчно **анализирующий и выполняющий** исходный код **во время выполнения программы**.

### 13. Что такое оператор и операнд?

*   **Оператор:**  Символ или ключевое слово, обозначающее **действие** (например, `+`, `-`, `=`).
*   **Операнд:**  Значение или переменная, над которой **выполняется операция**.

### 14. В каких случаях при записи математических выражений на языке С++ используются круглые скобки?

*   Изменение **порядка выполнения операций** (обеспечение нужной **приоритетности**).
*   Улучшение **читаемости** сложных выражений.
*   При **вызове функций**.

### 15. Как используются стандартные математические функции в С++?

*   Необходимо подключить заголовочный файл `<cmath>` (`#include <cmath>`).
*   Вызов функции по имени с указанием **аргументов в скобках**, например, `std::sqrt(x)`, `std::sin(angle)`.

## Тема 2: Программирование алгоритмов линейной структуры

### 1. Что такое программа на С++?

*   **Программа на C++:**  Последовательность **инструкций** на языке C++, предназначенная для **выполнения компьютером**.

### 2. Какая программа является линейной?

*   **Линейная программа:** Программа, где инструкции выполняются **последовательно**, одна за другой, **без ветвлений и циклов**.

### 3. Какова структура программы на С++?

*   `#include <iostream>` **(заголовочные файлы)**
*   `using namespace std;` **(пространство имен)**
*   `int main() {` **(главная функция)**
    *   `// объявления переменных`
    *   `// операторы`
    *   `return 0;`
*   `}`

### 4. Что такое идентификатор?

*   **Идентификатор:**  Имя, которое программист даёт **переменным, функциям, классам** и другим **элементам программы**.

### 5. По каким правилам создаются идентификаторы в С++?

*   Начинаются с **буквы** или **подчёркивания** (`_`).
*   Состоят из **букв, цифр и подчёркиваний**.
*   **Чувствительны к регистру** ( `myVar` и `myvar` - разные).
*   Не могут совпадать с **ключевыми словами** языка C++.

### 6. Что такое тип величины?

*   **Тип величины:**  Характеризует **вид данных**, которые может хранить переменная, и **операции**, которые можно над ней выполнять.

### 7. Какие типы величин используются в языке С++?

*   **Основные:** `int`, `float`, `double`, `char`, `bool`.
*   **Модификаторы:** `short`, `long`, `unsigned`.
*   **Производные:** массивы, указатели, структуры, классы.

### 8. Какие типы величин относятся к простым типам?

*   **Простые типы:** `int`, `float`, `double`, `char`, `bool`.

### 9. В каком диапазоне могут изменяться переменные типа int и float?

*   **`int`:**  Зависит от системы, обычно **-2<sup>31</sup> до 2<sup>31</sup>-1** (или **-2<sup>15</sup> до 2<sup>15</sup>-1** для `short int`).
*   **`float`:**  Приблизительно **±3.4 * 10<sup>-38</sup> до ±3.4 * 10<sup>38</sup>** (ограниченная точность).

### 10. Как описываются переменные в С++? (Привести пример.)

*   `тип_данных имя_переменной;`
*   `тип_данных имя_переменной = значение;`
*   **Пример:** `int age;` , `float price = 19.99;`

### 11. Что такое операторные скобки? Каково их назначение?

*   **Операторные скобки:** Фигурные скобки `{}`.
*   **Назначение:**  Ограничивают **блок кода**, например, тело функции `main()`.

### 12. Как выполняется команда присваивания?

*   **Команда присваивания:**  Оператор `=`.
*   **Выполнение:**  Значение **правого операнда** вычисляется и **присваивается** переменной, указанной в **левом операнде**.

### 13. Какая инструкция предназначена для вывода на экран сообщений?

*   **Вывод на экран:** `std::cout << "сообщение";`

### 14. Какая инструкция предназначена для ввода данных?

*   **Ввод данных:** `std::cin >> имя_переменной;`

### 15. Что такое заголовочный файл? Приведите пример заголовочного файла.

*   **Заголовочный файл:** Файл с расширением `.h` или `.hpp`, содержащий **объявления** функций, классов, констант и других **элементов**, используемых в программе.
*   **Пример:** `#include <iostream>`

### 16. Каково назначение заголовочных файлов?

*   **Назначение:** Предоставить **интерфейс** к библиотечным функциям и другим модулям, позволяя использовать их в программе. **Избежать повторного объявления одних и тех же сущностей.**

### 17. Как сохранить программу? (Устно)

*   (Устно: Выбрать "Сохранить" или "Сохранить как" в редакторе кода, указать имя файла с расширением `.cpp`.)

### 18. Как осуществить компиляцию текста программы? (Устно)

*   (Устно: Использовать компилятор C++ (например, g++) через командную строку: `g++ имя_файла.cpp -o имя_исполняемого_файла` или воспользоваться функционалом IDE.)

### 19. Как осуществить запуск программы? (Устно)

*   (Устно: Запустить исполняемый файл через командную строку: `./имя_исполняемого_файла` (Linux/macOS) или `имя_исполняемого_файла.exe` (Windows) или через IDE.)

### 20. Как считать готовую программу с диска? (Устно)

*   (Устно: Открыть файл с расширением `.cpp` в редакторе кода, выбрав "Открыть файл" или аналогичную опцию.)

## Тема 3: Операторы ветвления

### 1. Что такое составной оператор?

*   **Составной оператор (блок):** Последовательность **операторов**, заключенная в **фигурные скобки `{}`**, воспринимается как **один оператор**.

### 2. Какова полная (неполная) форма команды ветвления (блок-схема)?

*   **Полная форма:** **Ромб** (условие) с двумя выходами: "**Да**" (блок действий 1) и "**Нет**" (блок действий 2), оба сходятся далее.
*   **Неполная форма:** **Ромб** (условие) с двумя выходами: "**Да**" (блок действий) и "**Нет**" (выход без действий).

### 3. Каков алгоритм выполнения команды ветвления?

*   Вычисляется **условие** в скобках `if`.
*   Если **условие истинно (true, не равно 0)**:
    *   Для **полной формы**: выполняется **блок действий 1**.
    *   Для **неполной формы**: выполняется **блок действий**.
*   Если **условие ложно (false, равно 0)**:
    *   Для **полной формы**: выполняется **блок действий 2**.
    *   Для **неполной формы**: **никакие действия не выполняются**.

### 4. Каков алгоритм выполнения команды множественного ветвления (выбора)? Блок-схема.

*   Вычисляется **значение выражения** в скобках `switch`.
*   Выполняется **переход к метке `case`**, значение которой **совпадает** со значением выражения.
*   Выполняются **операторы**, следующие за меткой `case`.
*   При достижении оператора `break` происходит **выход из `switch`**.
*   Если **совпадение не найдено**, выполняются операторы после метки `default` (если есть).
*   **Блок-схема:**  **Многоугольник** (выражение), стрелки к **прямоугольникам** (`case значение 1`, `case значение 2`, ..., `default`), каждый с блоком действий и стрелкой к общей точке выхода.

### 5. Какие операторы сравнения используются в C++?

*   `==`  **Равно**
*   `!=`  **Не равно**
*   `>`   **Больше**
*   `<`   **Меньше**
*   `>=`  **Больше или равно**
*   `<=`  **Меньше или равно**

### 6. Что называется простым условием? Приведите примеры.

*   **Простое условие:** Выражение, содержащее **один оператор сравнения**.
*   **Примеры:**
    *   `x > 5`
    *   `age == 18`
    *   `name != "John"`

### 7. Что такое составное условие? Приведите примеры.

*   **Составное условие:**  Состоит из **нескольких простых условий**, объединенных **логическими операторами**.
*   **Примеры:**
    *   `(age > 12) && (age < 20)`
    *   `(grade == 'A') || (grade == 'B')`
    *   `!(is_raining)`

### 8. Какие логические операторы допускаются при составлении сложных условий?

*   `&&`  **Логическое "И" (AND)**
*   `||`  **Логическое "ИЛИ" (OR)**
*   `!`   **Логическое отрицание (NOT)**

### 9. Каков результат применения оператора логическое "И" (&&)?

*   Результат **истинен (true)**, только если **оба операнда истинны**.
*   В противном случае результат **ложный (false)**.

### 10. Каков результат применения оператора логическое "ИЛИ" (||)?

*   Результат **истинен (true)**, если **хотя бы один из операндов истинен**.
*   Результат **ложный (false)**, только если **оба операнда ложны**.

### 11. Каков результат применения оператора логическое отрицание (!)?

*   Если операнд **истинен (true)**, результат **ложный (false)**.
*   Если операнд **ложный (false)**, результат **истинный (true)**.

### 12. Каков общий вид (формат) инструкции «Ветвление»?

*   **Неполная форма:**
    ```cpp
    if (условие) {
        // блок действий;
    }
    ```
*   **Полная форма:**
    ```cpp
    if (условие) {
        // блок действий 1;
    } else {
        // блок действий 2;
    }
    ```
*   **Множественное ветвление:**
    ```cpp
    if (условие 1) {
        // блок действий 1;
    } else if (условие 2) {
        // блок действий 2;
    } else if (условие 3) {
        // блок действий 3;
    } else {
        // блок действий по умолчанию;
    }
    ```

### 13. Каков алгоритм выполнения условной (тернарной) операции (?:)? Приведите пример.

*   Вычисляется **условие** перед знаком вопроса `?`.
*   Если **условие истинно**, вычисляется и возвращается **значение выражения 1** после знака вопроса, до двоеточия `:`.
*   Если **условие ложно**, вычисляется и возвращается **значение выражения 2** после двоеточия `:`.
*   **Пример:** `int max_val = (a > b) ? a : b;` // Присваивает `max_val` большее из `a` и `b`.

### 14. Каков общий вид (формат) инструкции «Выбор»?

```cpp
switch (выражение) {
    case значение1:
        // операторы;
        break;
    case значение2:
        // операторы;
        break;
    // ...
    default:
        // операторы;
        break;
}
```

### 15. Может ли оператор ветвления содержать внутри себя другие ветвления?

*   **Да**, оператор ветвления (`if`, `if-else`, `if-else if`) **может содержать внутри себя другие операторы ветвления** (вложенные ветвления). Это позволяет создавать более сложные логические структуры.

## Тема 4: Циклы

### 1. Какие базовые алгоритмические конструкции можно реализовать средствами языка С++?

*   **Следование (последование):**  Последовательное выполнение операторов.
*   **Ветвление (выбор):** `if`, `if-else`, `switch`.
*   **Цикл (повторение):** `for`, `while`, `do-while`.

### 2. Что называется циклом?

*   **Цикл:**  Алгоритмическая конструкция, обеспечивающая **многократное выполнение** блока кода.

### 3. Что такое тело цикла?

*   **Тело цикла:**  Блок кода, который **повторно выполняется** в цикле.

### 4. Что такое параметр цикла?

*   **Параметр цикла:**  Переменная, **управляющая** количеством итераций цикла (чаще всего в `for`).

### 5. Что такое итерация?

*   **Итерация:**  Одно **единичное выполнение** тела цикла.

### 6. Что такое зацикливание?

*   **Зацикливание:**  Ситуация, когда условие продолжения цикла **никогда не становится ложным**, и цикл выполняется **бесконечно**.

### 7. Какие типы циклов существуют?

*   **С предусловием:** `while`.
*   **С постусловием:** `do-while`.
*   **С параметром (счетчиком):** `for`.

### 8. Какие инструкции используются для реализации циклов на С++?

*   `for`, `while`, `do-while`.

### 9. Какая инструкция используется для реализации цикла с параметром?

*   `for`.

### 10. Можно ли использовать в теле цикла переменную, являющуюся параметром цикла?

*   **Да**, но **следует соблюдать осторожность**, изменение параметра цикла внутри тела может усложнить понимание и привести к ошибкам.

### 11. Какая инструкция используется для реализации цикла с предусловием?

*   `while`.

### 12. От чего зависит количество повторений тела цикла с предусловием?

*   От **истинности условия**, проверяемого **перед каждой итерацией**. Цикл выполняется, пока условие **истинно**.

### 13. Какая инструкция используется для реализации цикла с постусловием?

*   `do-while`.

### 14. Какие из конструкций повторения могут привести к зацикливанию?

*   **Любая**, если условие продолжения цикла **никогда не становится ложным**.

### 15. Как работает цикл со счетчиком?

*   Инициализация **параметра цикла**, проверка **условия продолжения**, выполнение **тела цикла**, изменение **параметра цикла** (инкремент/декремент). Повторяется, пока условие истинно.

### 16. В каком случае в теле цикла используются операторные скобки?

*   Если тело цикла содержит **более одного оператора**.

### 17. Каковы отличия между циклами с пред- и с постусловием?

*   **С предусловием (`while`):** Условие проверяется **перед** выполнением тела, тело может **не выполниться ни разу**.
*   **С постусловием (`do-while`):** Условие проверяется **после** выполнения тела, тело выполняется **как минимум один раз**.

## Тема 5: Подпрограммы

### 1. Что такое подпрограмма?

*   **Подпрограмма:**  Именованный **блок кода**, выполняющий **конкретную задачу**. Позволяет **повторно использовать код** и **организовать программу**.

### 2. Как подпрограмму можно реализовать в С++?

*   С помощью **функций**.

### 3. Какие параметры называются формальными?

*   **Формальные параметры:** Переменные, **указанные в объявлении** (заголовке) **функции**. Служат **местозаполнителями** для фактических значений.

### 4. Какие параметры называются фактическими?

*   **Фактические параметры:**  Значения или переменные, **передаваемые функции при ее вызове**. Подставляются на место формальных параметров.

### 5. Что такое переменная?

*   **Переменная:** Именованная **область памяти** для хранения **данных определенного типа**.

### 6. Что такое область действия идентификатора?

*   **Область действия идентификатора:**  Часть программы, где **идентификатор (например, имя переменной или функции)** является **видимым и доступным**.

### 7. Что такое локальная переменная? Что такое глобальная переменная?

*   **Локальная переменная:** Объявлена **внутри блока кода** (например, функции). Видима **только внутри этого блока**.
*   **Глобальная переменная:** Объявлена **вне всех функций**. Видима **во всей программе** (в файле, где объявлена, и в других файлах при использовании `extern`).

### 8. Какова область действия локальных идентификаторов?

*   **Область действия локальных идентификаторов:**  Блок кода, **где они объявлены** (обычно функция или составной оператор `{}`).

### 9. Какова область действия глобальных идентификаторов?

*   **Область действия глобальных идентификаторов:**  Файл, **где они объявлены**, от места объявления до конца файла. Могут быть доступны в других файлах при использовании ключевого слова `extern`.

### 10. Что такое функция?

*   **Функция:**  Тип подпрограммы в C++. Имеет **имя**, может принимать **параметры** и возвращать **значение**.

### 11. Чем отличается объявление функции от ее определения (описания)?

*   **Объявление функции (прототип):**  Указывает **имя функции, типы параметров и возвращаемый тип**. Заканчивается точкой с запятой `;`. Сообщает компилятору о существовании функции.
*   **Определение функции (описание):** Содержит **объявление функции и тело функции** (блок кода с инструкциями). Реализует действия, которые выполняет функция.

### 12. Перечислите составные части описания функции.

*   **Заголовок функции:**  Тип возвращаемого значения, имя функции, список формальных параметров в скобках.
*   **Тело функции:**  Блок кода в фигурных скобках `{}` с инструкциями, выполняемыми функцией.

### 13. Что такое прототип функции?

*   **Прототип функции:**  Объявление функции,  содержащее **информацию о ее интерфейсе** (имя, параметры, возвращаемый тип), но **без реализации**. Необходимо, если функция вызывается до ее определения.

### 14. Как описывается функция пользователя в программе?

*   **Тип\_возвращаемого\_значения ИмяФункции(Тип1 параметр1, Тип2 параметр2, ...)**
    **{**
        **// Тело функции**
        **return значение;  // если функция возвращает значение**
    **}**

### 15. Что такое возвращаемое значение функции?

*   **Возвращаемое значение функции:**  Результат работы функции, который **она передает обратно** в место своего вызова. Тип возвращаемого значения указывается в объявлении функции. Возвращается с помощью оператора `return`.

### 16. Как осуществляется вызов функций из основной программы?

*   Указать **имя функции** и **в скобках передать фактические параметры** (если есть). Например: `имяФункции(аргумент1, аргумент2);`. Если функция возвращает значение, его можно присвоить переменной: `результат = имяФункции(аргументы);`.

## Тема 6: Итерация и рекурсия

### 1. Какой процесс называется итеративным?

*   **Итеративный процесс:**  Многократное **повторение** одного и того же блока **кода** до достижения **условия остановки**.

### 2. Каким образом реализуются итеративные процессы?

*   **Реализация:** С помощью **циклов** (`for`, `while`, `do-while`).

### 3. Какой алгоритм называется рекурсивным?

*   **Рекурсивный алгоритм:** Алгоритм, вызывающий **сам себя** для решения **подзадачи**.

### 4. Какая функция называется прямо рекурсивной? Косвенно рекурсивной?

*   **Прямо рекурсивная:** Функция вызывает **саму себя непосредственно**.
*   **Косвенно рекурсивная:** Функция вызывает **другую функцию**, которая, в свою очередь, вызывает **исходную функцию**.

### 5. Что такое стек? В какой последовательности происходит заполнение стека и выбор элементов из стека?

*   **Стек:** Структура данных LIFO (**Last-In, First-Out**).
*   **Заполнение:**  Элементы добавляются **на вершину стека** (`push`).
*   **Выбор:** Элементы извлекаются **с вершины стека** (`pop`).

### 6. Что должно обязательно присутствовать в теле рекурсивно описанной функции?

*   **Обязательно:** **Базовый случай (условие остановки)** и **рекурсивный вызов**.

### 7. Перечислите различия между итерацией и рекурсией.

*   **Итерация:** Циклы, явное управление, **обычно более эффективна по памяти**.
*   **Рекурсия:** Вызов функции, неявное управление стеком, **может быть более понятной для некоторых задач**.

### 8. Что произойдет, если рекурсивный алгоритм будет вызывать сам себя «бесконечное» число раз?

*   **Бесконечная рекурсия:** **Переполнение стека**, **ошибка выполнения программы**.

### 9. Как предотвратить бесконечное выполнение рекурсивного алгоритма?

*   **Предотвращение:**  Корректно определенный **базовый случай**, гарантированное **приближение к базовому случаю** при каждом рекурсивном вызове.

### 10. Верно ли, что решение задачи, реализуемое рекурсивным алгоритмом, можно выразить, используя итерацию?

*   **Верно:** Да, **любой рекурсивный алгоритм можно реализовать итеративно** (и наоборот).

## Тема 7: Одномерные массивы

### 1. Дайте определение производного типа данных, структурированного типа.

*   **Производный тип данных:** Тип данных, построенный на основе **других, ранее определенных типов**.
*   **Структурированный тип данных:** Тип данных, позволяющий объединять **несколько элементов (данных)** под одним именем.

### 2. Дайте определение массива.

*   **Массив:**  **Упорядоченная** коллекция **однотипных** элементов, расположенных в **непрерывной области памяти**, доступ к которым осуществляется по **индексу**.

### 3. Каким может быть тип элементов массива?

*   Тип элементов массива может быть любым **допустимым типом данных** в языке программирования, например:
    *   **Целочисленные типы:** `int`, `char`, `short`, `long`.
    *   **Типы с плавающей точкой:** `float`, `double`.
    *   **Символьный тип:** `char`.
    *   **Булев тип:** `bool`.
    *   **Указатели** на другие типы.
    *   **Объекты классов** (применимо к объектно-ориентированным языкам).

### 4. Имя, размер и размерность массива.

*   **Имя массива:**  **Идентификатор**, используемый для ссылки на массив.
*   **Размер массива:**  **Количество элементов**, которое может хранить массив. Задается **целым числом**.
*   **Размерность массива:**  **Количество индексов**, необходимых для доступа к конкретному элементу. Для одномерного массива размерность равна **одному**.

### 5. Какова структура одномерного массива?

*   Одномерный массив представляет собой **линейную последовательность** элементов, расположенных **друг за другом** в памяти. Каждый элемент имеет свой **индекс**, начинающийся, как правило, с **нуля**.

### 6. Правила описания одномерного массива.

*   В C++: `тип имя_массива[размер];`
    *   `тип`:  Тип данных элементов массива.
    *   `имя_массива`: Имя массива.
    *   `размер`:  Количество элементов в массиве (должно быть **константным выражением** на момент компиляции для статических массивов).
*   Пример: `int myArray[10];` // Массив из 10 целых чисел.

### 7. Как осуществляется доступ к элементам одномерного массива?

*   Доступ к элементам осуществляется по **индексу**, указанному в **квадратных скобках** после имени массива.
*   Индексация начинается с **нуля**.
*   Пример: `myArray[0]` (доступ к первому элементу), `myArray[5]` (доступ к шестому элементу).

### 8. Как осуществляется ввод массива?

*   Ввод массива обычно осуществляется с использованием **цикла**, который перебирает элементы массива по индексу. Внутри цикла происходит **чтение значения** и присваивание его соответствующему элементу массива.

### 9. Какие способы ввода массива вы знаете?

*   **Поэлементный ввод с клавиатуры:** Использование цикла `for` и `std::cin` для ввода каждого элемента.
*   **Инициализация при объявлении:** Присваивание значений элементам массива непосредственно при его создании (для статических массивов). Пример: `int arr[] = {1, 2, 3};`
*   **Чтение из файла:**  Считывание значений элементов массива из внешнего файла.
*   **Генерация случайных значений:** Заполнение массива случайными числами.

### 10. Вывод линейного массива.

*   Вывод массива также обычно осуществляется с использованием **цикла**, который перебирает элементы массива по индексу. Внутри цикла происходит **вывод значения** текущего элемента на экран (или в другой поток вывода).
*   Можно выводить элементы через **пробел, запятую, новую строку** и т.д. для удобства чтения.
*   Пример (C++):
    ```cpp
    for (int i = 0; i < size; ++i) {
        std::cout << myArray[i] << " ";
    }
    std::cout << std::endl;
    ```

## Тема 8: Двумерные массивы

### 1. Дайте определение массива.

*   **Массив:**  **Совокупность** однотипных элементов, расположенных в **памяти последовательно** и имеющих **общее имя**. Доступ к элементам осуществляется по **индексу**.

### 2. Какие типы данных не допустимы для компонентов массива?

*   **Недопустимые типы:** **Ссылочные типы** (в некоторых контекстах, особенно в C++ без косвенности), **абстрактные классы** (нельзя создать экземпляр). В целом, типы, **размер которых не известен на этапе компиляции** или которые **нельзя скопировать**.

### 3. Может ли левая граница индексов массива быть отрицательной?

*   **Отрицательная граница:** В **большинстве языков (C++, Java, Python)** – **нет**. Индексация обычно начинается с **0**. В некоторых языках (например, Fortran) можно задавать произвольные границы.

### 4. Какой массив называется двумерным?

*   **Двумерный массив:**  Массив, элементы которого расположены в **виде таблицы**, имеющей **строки и столбцы**. Для доступа к элементу требуется **два индекса** (номер строки и номер столбца).

### 5. Правила описания двумерного массива.

*   **Описание:** `тип_данных имя_массива[количество_строк][количество_столбцов];` (C++)
*   **Пример:** `int matrix[3][4];`

### 6. Как осуществляется доступ к элементам двумерного массива?

*   **Доступ:**  Указание **имени массива** и **двух индексов** в квадратных скобках: `имя_массива[номер_строки][номер_столбца]`. Индексация обычно **начинается с 0**.

### 7. Как осуществляется ввод двумерного массива?

*   **Ввод:**  Чаще всего с использованием **вложенных циклов**. Внешний цикл перебирает **строки**, внутренний – **столбцы**. Внутри цикла считывается значение для текущего элемента.

### 8. Какие способы ввода двумерного массива вы знаете?

*   **Способы ввода:**
    *   **Поэлементный ввод с клавиатуры** (используя вложенные циклы и `cin`).
    *   **Инициализация при объявлении** (для статических массивов).
    *   **Чтение из файла**.
    *   **Генерация случайных значений**.
    *   **Присваивание значений из другого массива**.

### 9. Размещение массива в памяти ЭВМ.

*   **Размещение:**  Элементы двумерного массива располагаются в **памяти последовательно**. Чаще всего используется **построчное** (row-major order) или **постолбцовое** (column-major order) размещение. **C++ использует построчное размещение.**

### 10. Вывод двумерного массива.

*   **Вывод:**  Аналогично вводу, чаще всего используются **вложенные циклы**. Внешний цикл перебирает **строки**, внутренний – **столбцы**. Внутри цикла выводится значение текущего элемента. Для улучшения читаемости можно добавлять **пробелы или табуляции** между элементами и **переводы строк** после каждой строки массива.

### 11. Может ли инструкция `cout << x;` ввести массив `x` целиком?

*   **`cout << x;`:** **Нет**. В C++ для массивов, при использовании `cout` с именем массива без индексов, выводится **адрес первого элемента массива** (указатель на начало массива), а **не содержимое массива целиком**. Для вывода содержимого необходимо использовать **циклы**.

## Тема 9: Алгоритмы решения задач внутренней сортировки и алгоритмы поиска информации

### 1. Понятие сложности алгоритмов.

*   **Сложность алгоритма:**  Мера **количества ресурсов** (обычно **времени** или **памяти**), необходимых для выполнения алгоритма в зависимости от **размера входных данных (n)**. Обычно выражается в **O-нотации** ("О большое").

### 2. На какие классы делятся алгоритмы в соответствии с их временной или пространственной сложностью?

*   **По временной сложности:**
    *   **O(1):**  **Константное время**, не зависит от размера данных.
    *   **O(log n):** **Логарифмическое время**,  быстро растет с увеличением n.
    *   **O(n):** **Линейное время**,  время выполнения пропорционально размеру данных.
    *   **O(n log n):** **Линейно-логарифмическое время**,  достаточно эффективно для больших данных.
    *   **O(n^2):** **Квадратичное время**,  менее эффективно для больших данных.
    *   **O(2^n), O(n!):** **Экспоненциальное/факториальное время**,  непрактично для больших данных.
*   **По пространственной сложности:** Аналогичные классы, но оценивается **объем используемой памяти**.

### 3. Постановка задачи сортировки данных.

*   **Задача сортировки:** Расположить элементы **коллекции (массива, списка)** в **определенном порядке** (обычно **неубывающем** или **невозрастающем**) на основе **значения ключа** каждого элемента.

### 4. Прямые и быстрые методы внутренней сортировки.

*   **Прямые (простые) методы:** Легки в реализации, но менее эффективны для больших наборов данных (**O(n^2)**):
    *   Сортировка **вставками**.
    *   Сортировка **выбором**.
    *   Сортировка **обменами** (пузырьковая).
*   **Быстрые (эффективные) методы:** Более сложны в реализации, но эффективны для больших данных (**O(n log n)** в среднем):
    *   Сортировка **слиянием**.
    *   Быстрая сортировка (**QuickSort**).
    *   Пирамидальная сортировка (**HeapSort**).

### 5. Алгоритм сортировки массива методом вставки.

*   **Идея:**  Последовательно просматриваем элементы. Каждый новый элемент **вставляется** на **подходящее место** в уже **отсортированной части** массива.
*   **Шаги:**
    1. Начинаем со второго элемента (считая первый отсортированным).
    2. Берем текущий элемент.
    3. Сравниваем его с элементами в отсортированной части слева, сдвигая большие элементы вправо.
    4. Вставляем текущий элемент на освободившееся место.
    5. Повторяем для всех оставшихся элементов.

### 6. Алгоритм сортировки массива методом прямого выбора.

*   **Идея:** На каждой итерации находим **минимальный (или максимальный) элемент** в **неотсортированной части** массива и **меняем его местами** с **первым элементом** этой части.
*   **Шаги:**
    1. Находим минимальный элемент в массиве.
    2. Меняем его местами с первым элементом.
    3. Находим минимальный элемент в оставшейся части массива (со второго элемента).
    4. Меняем его местами со вторым элементом.
    5. Повторяем, пока вся часть массива не будет отсортирована.

### 7. Алгоритм сортировки массива методом прямого обмена.

*   **Идея (Пузырьковая сортировка):**  Последовательно сравниваем **пары соседних элементов**. Если они находятся в **неправильном порядке**, меняем их местами. Большие элементы "всплывают" к концу массива.
*   **Шаги:**
    1. Сравниваем первый и второй элементы, меняем местами, если нужно.
    2. Сравниваем второй и третий элементы, меняем местами, если нужно.
    3. Проходим так до конца массива. Самый большой элемент окажется в конце.
    4. Повторяем проходы, исключая последний отсортированный элемент, пока не останется один неотсортированный элемент.

### 8. Понятие инверсии.

*   **Инверсия:** Пара элементов в массиве, где **элемент, стоящий раньше**, **больше** **элемента, стоящего позже**. Количество инверсий может служить мерой **неотсортированности** массива.

### 9. Постановка задачи поиска элемента в массиве.

*   **Задача поиска:** Найти **индекс** (или факт наличия/отсутствия) **элемента** с **заданным значением ключа** в **коллекции (массиве, списке)**.

### 10. Алгоритм последовательного (линейного) поиска.

*   **Идея:**  Проходим по элементам массива **последовательно**, от начала до конца, и **сравниваем** каждый элемент с **искомым ключом**.
*   **Шаги:**
    1. Начинаем с первого элемента массива.
    2. Сравниваем текущий элемент с искомым ключом.
    3. Если совпадает, возвращаем индекс текущего элемента (или true).
    4. Если дошли до конца массива и не нашли, возвращаем -1 (или false).

### 11. Алгоритм бинарного поиска.

*   **Идея:**  Эффективный алгоритм поиска в **отсортированном** массиве. На каждой итерации **делим область поиска пополам**.
*   **Требование:** Массив должен быть **отсортирован**.
*   **Шаги:**
    1. Устанавливаем **левую** и **правую** границы поиска.
    2. Находим **средний** элемент массива.
    3. Сравниваем средний элемент с искомым ключом:
        *   Если совпадает, возвращаем индекс.
        *   Если ключ меньше среднего, сужаем область поиска до левой половины.
        *   Если ключ больше среднего, сужаем область поиска до правой половины.
    4. Повторяем, пока не найдем элемент или область поиска не станет пустой.

## Тема 10: Указатели и массивы

### 1. Что такое указатель?

*   **Указатель:** Переменная, хранящая **адрес в памяти** другой переменной.

### 2. Каков общий вид объявления указателя? Приведите пример.

*   **Общий вид:** `тип_данных *имя_указателя;`
*   **Пример:** `int *ptr;` // Указатель на целое число

### 3. Как описать несколько указателей на данные одного и того же типа?

*   `тип_данных *ptr1, *ptr2, *ptr3;` // Важно ставить `*` перед каждым именем

### 4. Каковы особенности инициализации указателей?

*   Присваивается **адрес** существующей переменной (`&`) или **значение другого указателя**. Можно инициализировать `nullptr` **(в C++11 и новее)**. **Нельзя присваивать произвольное число, если это не явное приведение типа.**

### 5. Что означает NULL?

*   **NULL (или `nullptr` в C++11):**  Указатель, **не указывающий ни на какой допустимый объект** в памяти.

### 6. Приведите пример использования операции взятия адреса (адресации). Поясните принцип проиллюстрированного действия.

*   **Пример:**
    ```c++
    int num = 10;
    int *ptr = &num;
    ```
*   **Пояснение:** Оператор `&` **возвращает адрес** переменной `num`. Этот адрес **присваивается** указателю `ptr`. Теперь `ptr` **указывает на** `num`.

### 7. Приведите пример использования операции «взятия значения по адресу» (косвенной адресации или разыменования). Поясните принцип проиллюстрированного действия.

*   **Пример:**
    ```c++
    int num = 10;
    int *ptr = &num;
    int value = *ptr;
    ```
*   **Пояснение:** Оператор `*` перед `ptr` **обращается к значению**, хранящемуся **по адресу**, на который указывает `ptr`. `value` теперь **равна** `10`.

### 8. Особенности использования символа «*».

*   В объявлении: обозначает, что переменная является **указателем**.
*   Перед именем указателя: операция **разыменования** (получение значения по адресу).
*   В арифметических операциях:  обычное **умножение**. **Контекст определяет значение.**

### 9. Какова взаимосвязь между именем массива и указателем?

*   Имя массива **без индекса** является **константным указателем** на его **первый элемент**.

### 10. Как задать указателю адрес первого элемента массива.

*   **Способ 1:** `int arr[5]; int *ptr = arr;` // Имя массива само по себе - адрес первого элемента
*   **Способ 2:** `int arr[5]; int *ptr = &arr[0];` // Явное взятие адреса первого элемента

### 11. Как получить значение i-го элемента массива при использовании указателя?

*   **Используя арифметику указателей:** `*(ptr + i)`
*   **Используя синтаксис массива:** `ptr[i]` // Эквивалентно арифметике указателей

### 12. Каково различие между именем массива и соответствующим указателем?

*   Имя массива - **константный указатель**, его **нельзя изменить**.
*   Указатель - **переменная**, её **значение (адрес)** можно изменять.
*   `sizeof(массив)` возвращает **размер всего массива**, `sizeof(указатель)` возвращает **размер указателя**.

### 13. Каков порядок объявления динамических массивов с использованием операции new? С использованием функции malloc?

*   **`new` (C++):** `тип_данных *имя_массива = new тип_данных[размер];`
*   **`malloc` (C):** `тип_данных *имя_массива = (тип_данных*)malloc(размер * sizeof(тип_данных));` **(требуется явное приведение типа)**

### 14. Как освободить память, отведенную под динамический массив?

*   **`new[]` (C++):** `delete[] имя_массива;`
*   **`malloc` (C):** `free(имя_массива);`

### 15. Каковы основные правила передачи массивов в качестве параметров функции?

*   Массив **преобразуется в указатель** на свой первый элемент.
*   Размер массива **не передается автоматически**, его нужно передавать **отдельным параметром**.
*   Изменения элементов массива **внутри функции** отразятся **на исходном массиве**.

## Тема 11: Особенности работы с функциями

### 1. Перечислите способы передачи параметров в функцию.

*   **По значению:**  Передаётся **копия** значения.
*   **По адресу:** Передаётся **указатель** на переменную.
*   **По ссылке:** Передаётся **псевдоним** переменной.

### 2. Особенности передачи параметров в функцию по значению.

*   Функция работает с **копией** аргумента.
*   Изменения внутри функции **не влияют** на исходную переменную.
*   **Безопасно** с точки зрения случайного изменения оригинала.

### 3. Особенности передачи параметров в функцию по адресу.

*   Функция получает **адрес** оригинальной переменной.
*   Изменения внутри функции **влияют** на исходную переменную.
*   Требуется использование **оператора разыменования** (`*`) для доступа к значению.
*   Можно передавать **большие объемы данных без копирования**.

### 4. Каковы особенности передачи параметров в функцию по ссылке?

*   Функция работает непосредственно с **оригинальной** переменной.
*   Изменения внутри функции **влияют** на исходную переменную.
*   **Не требует разыменования** внутри функции.
*   Ссылка **должна быть инициализирована** при объявлении (в контексте параметров функции - при вызове функции).
*   Нельзя передать **константу** неконстантной ссылке (без `const`).

### 5. Может ли функция возвращать массив или функцию в качестве результата своей работы?

*   **Массив:**  **Нет, напрямую**. Можно вернуть **указатель** на первый элемент массива (выделенного динамически) или использовать `std::array` или `std::vector`.
*   **Функцию:** **Нет, напрямую**. Можно вернуть **указатель на функцию** (функтор) или лямбда-выражение.

### 6. Перечислите способы вызова функций.

*   **Обычный вызов:** `functionName(argument1, argument2);`
*   **Вызов через указатель на функцию:** `(*funcPtr)(argument1, argument2);`
*   **Вызов через объект (метод класса):** `object.methodName(arguments);`

### 7. Какое служебное слово используют для переименования типов?

*   `typedef` **(C, C++ до C++11)**
*   `using` **(C++11 и новее)**

### 8. Что понимают под перегрузкой функций?

*   Возможность иметь **несколько функций с одинаковым именем**, но **разным набором параметров** (количество, типы или порядок следования).

### 9. Какой процесс называют разрешением «уточнением» перегрузки?

*   Процесс, при котором компилятор выбирает **конкретную версию перегруженной функции** для вызова, основываясь на **типах и количестве переданных аргументов**.

### 10. На чем основан механизм разрешения перегрузки? Дайте пояснения.

*   Основан на **сопоставлении типов аргументов** при вызове функции с типами параметров в объявлениях перегруженных функций. Компилятор ищет **наиболее подходящую** версию. Применяются правила **неявных преобразований типов**.

### 11. Перечислите правила описания перегруженных функций.

*   Функции должны иметь **одинаковое имя**.
*   Должны отличаться **списком параметров** (количество, типы или порядок следования).
*   Тип возвращаемого значения **не является** критерием для перегрузки.
Okay, ready for the next set of questions!

## Тема 12: Строки как массив элементов типа char

### 1. Что представляет из себя строка в программе, написанной на ЯП Си?

*   **Строка:**  **Массив** элементов типа `char`, заканчивающийся **нулевым символом** (`\0`).

### 2. Что представляет собой строка:

*   **в) последовательность символов ПЭВМ:** 

### 3. Как может быть описана строка в Си?

*   Как **массив** символов `char`.
*   Как **указатель** на `char`.

### 4. Приведите пример объявления строки как массива символов.

*   `char str[50];`
*   `char message[] = "Hello";`

### 5. Приведите пример объявления строки как переменной-указателя на строку.

*   `char *str;`
*   `char *greeting = "Hi there!";`

### 6. Что является признаком окончания строки?

*   **Нулевой символ** (`\0`).

### 7. Как осуществляется доступ к элементам строки?

*   Как к элементам **массива** по **индексу** (например, `str[0]`).

### 8. Какое максимальное количество символов может содержать строка?

*   На единицу **меньше** размера выделенного **массива** (для учета `\0`).

### 9. Как при описании строки может быть задана ее длина?

*   **Явно** при объявлении массива (`char str[50];`).
*   **Неявно** при инициализации строковым литералом (`char message[] = "Text";` - длина определится автоматически).

### 10. Может ли в процессе выполнения программы фактическая длина строки стать больше, чем объявлено в разделе описания? Что произойдет в этом случае?

*   **Нет**, не должна. Это приведет к **переполнению буфера** и **неопределенному поведению** (возможно, повреждению других данных или аварийному завершению программы).

### 11. Перечислите типовые операции над строками.

*   **Копирование** (strcpy, strncpy).
*   **Конкатенация (слияние)** (strcat, strncat).
*   **Сравнение** (strcmp, strncmp).
*   **Поиск** символа/подстроки (strchr, strstr).
*   **Определение длины** (strlen).

### 12. Перечислите основные функции обработки строк.

*   `<string.h>`: `strcpy`, `strncpy`, `strcat`, `strncat`, `strcmp`, `strncmp`, `strlen`, `strchr`, `strstr`, `sprintf`, `sscanf`, `strtok`.

## Тема 13: Строки как объект специального класса string

### 1. Как описывается переменная-строка, являющаяся экземпляром класса string?

*   `std::string имя_переменной;`
*   `std::string имя_переменной = "начальное значение";`

### 2. Как осуществляется доступ к элементам строки?

*   По индексу, как к массиву: `имя_строки[индекс]`. **Нумерация с 0.**
*   Метод `at(индекс)` **(с проверкой границ)**.

### 3. Перечислите типовые операции над строками.

*   Присваивание (`=`).
*   Сравнение (`==`, `!=`, `<`, `>`, `<=`, `>=`).
*   Конкатенация (`+`, `+=`).
*   Доступ к символам.
*   Получение длины (`length()`, `size()`).
*   Поиск подстроки (`find()`, `rfind()`).
*   Вставка (`insert()`).
*   Удаление (`erase()`).
*   Замена (`replace()`).
*   Выделение подстроки (`substr()`).

### 4. Как выполняется инициализация строк?

*   Пустая строка: `std::string s;`.
*   Строковым литералом: `std::string s = "hello";`.
*   Копированием другой строки: `std::string s2 = s;`.
*   Частью строкового литерала: `std::string s("hello", 2);` **(первые 2 символа)**.
*   Повторением символа: `std::string s(10, 'a');` **(10 символов 'a')**.

### 5. Как выполняется ввод/вывод строк, являющихся объектом класса string?

*   Ввод: `std::cin >> имя_строки;` **(до пробельного символа)**. `std::getline(std::cin, имя_строки);` **(вся строка до символа новой строки)**.
*   Вывод: `std::cout << имя_строки;`.

### 6. Как выполняется сравнение строк?

*   Операторы сравнения (`==`, `!=`, `<`, `>`, `<=`, `>=`). **Лексикографическое сравнение.**
*   Метод `compare()` **(возвращает 0, <0, >0)**.

### 7. Как выполняется конкатенация строк?

*   Оператор `+`: `string3 = string1 + string2;`.
*   Оператор `+=`: `string1 += string2;`.
*   Метод `append()`: `string1.append(string2);`.

### 8. Может ли в процессе выполнения программы измениться фактическая длина строки?

*   **Да.**  Использование операций добавления, удаления, замены, присваивания может изменить длину строки. `std::string` управляет памятью динамически.

### 9. Перечислите основные функции обработки строк.

*   `length()`, `size()` **(получение длины)**.
*   `empty()` **(проверка на пустоту)**.
*   `clear()` **(очистка строки)**.
*   `push_back(char c)` **(добавление символа в конец)**.
*   `append(const string& str)` **(добавление строки в конец)**.
*   `insert(size_t pos, const string& str)` **(вставка подстроки)**.
*   `erase(size_t pos, size_t count)` **(удаление символов)**.
*   `replace(size_t pos, size_t count, const string& str)` **(замена подстроки)**.
*   `substr(size_t pos, size_t count)` **(выделение подстроки)**.
*   `find(const string& str, size_t pos = 0)` **(поиск подстроки)**.
*   `rfind(const string& str, size_t pos = npos)` **(поиск с конца)**.
*   `compare(const string& str)` **(сравнение)**.
*   `at(size_t pos)` **(доступ к символу с проверкой)**.
*   `front()`, `back()` **(доступ к первому/последнему символу)**.

## Тема 14: Структуры

### 1. Какие типы данных относятся к простым, а какие к составным?

*   **Простые:** `int`, `float`, `double`, `char`, `bool`, указатели.
*   **Составные:** Массивы, структуры, объединения, классы.

### 2. Что такое структура (struct)?

*   **Структура:**  Составной тип данных, объединяющий **несколько переменных** (полей) **разных типов** под одним именем.

### 3. Как объявляются структуры?

*   `struct ИмяСтруктуры { Тип1 поле1; Тип2 поле2; ... };`

### 4. Верно ли, что поля структуры должны иметь один и тот же тип?

*   **Нет.** Поля структуры **могут иметь разные типы данных**.

### 5. Чем отличается структура от массива?

*   **Структура:** Хранит **разнотипные** элементы, доступ по **имени поля**.
*   **Массив:** Хранит **однотипные** элементы, доступ по **индексу**.

### 6. Какие операции допустимы над структурой в целом?

*   Присваивание **(если структура не содержит массивов фиксированного размера в стиле C)**, передача в функцию/возврат из функции **(по значению)**, взятие адреса (`&`).

### 7. Как осуществляется ссылка на компоненты структуры?

*   Через оператор **точка (`.`)** для переменных типа структура: `имя_переменной.имя_поля`.
*   Через оператор **стрелка (`->`)** для указателей на структуру: `имя_указателя->имя_поля`.

### 8. Можно ли в качестве поля структуры описать структуру?

*   **Да.** Это называется **вложенной структурой**.

## Тема 15: Файлы

### 1. Понятие файла в C/C++.

*   **Файл:** Именованная область **памяти на носителе** для хранения **данных**. Рассматривается как **последовательность байтов**.

### 2. Классификация файлов.

*   **Текстовые:** Содержат **читаемые символы**, разбитые на строки.
*   **Бинарные:**  Хранят данные в **произвольном формате**, не обязательно текстовом.

### 3. Какого типа могут быть компоненты файла?

*   **Любого типа данных**, представимого в виде **последовательности байтов** (символы, числа, структуры, объекты и т.д.).

### 4. Нужно ли при определении файла заранее указывать его длину?

*   **Нет**, длина файла **динамически изменяется** при записи данных. При объявлении **указывается только имя (логическое)** и режим доступа.

### 5. Чем отличается файл от массива?

*   **Файл:**  Хранится на **внешнем носителе**, **постоянное хранение**.
*   **Массив:** Хранится в **оперативной памяти**, **временное хранение** во время выполнения программы. Размер массива часто фиксирован при объявлении.

### 6. Понятие о логическом и физическом имени файла.

*   **Логическое имя:**  Имя, используемое **в программе** для работы с файлом (например, переменная файлового указателя).
*   **Физическое имя:**  Реальное имя файла **в файловой системе** на диске (например, "data.txt").

### 7. Что понимается под чтением из файла и что под записью в файл?

*   **Чтение:**  Получение **данных из файла** и передача их в программу.
*   **Запись:**  Передача **данных из программы** и сохранение их в файле.

### 8. Типы доступа к файлам.

*   **Последовательный:**  Доступ к данным **по порядку**, начиная с начала файла.
*   **Прямой (произвольный):** Доступ к данным **в любом месте файла** по смещению или номеру записи.

### 9. Что такое последовательный файл?

*   Файл, доступ к записям которого осуществляется **последовательно**, одна за другой. Для доступа к середине нужно прочитать все предыдущие записи.

### 10. Какова общая форма создания файла (Си)?

*   `FILE *fopen(const char *filename, const char *mode);` где `mode` включает `"w"` (запись) или `"wb"` (бинарная запись).

### 11. Какова общая форма чтения файла (Си)?

*   `FILE *fopen(const char *filename, const char *mode);` где `mode` включает `"r"` (чтение) или `"rb"` (бинарное чтение).

### 12. Как осуществляется обработка файлов с использованием подхода в стиле языка С++?

*   Используются **классы из библиотеки `<fstream>`**: `ofstream` (для записи), `ifstream` (для чтения), `fstream` (для обоих). Работа с файлами осуществляется **через объекты этих классов** и **потоковые операции (`<<`, `>>`)**.

### 13. Перечислите стандартные функции для работы с файлами последовательного доступа

*   `fopen()` (открыть файл), `fclose()` (закрыть файл), `fprintf()` (запись форматированных данных), `fscanf()` (чтение форматированных данных), `fputc()` (запись символа), `fgetc()` (чтение символа), `fputs()` (запись строки), `fgets()` (чтение строки), `feof()` (проверка конца файла).

### 14. Перечислите библиотечные функции, используемые для работы с файлами прямого доступа.

*   `fseek()` (установка позиции указателя), `ftell()` (получение текущей позиции указателя), `fread()` (чтение блока данных), `fwrite()` (запись блока данных).

## Тема 16: Списки

### 1. Статические vs. Динамические величины:

*   **Статические:** Размер фиксируется **на этапе компиляции** (массивы).
*   **Динамические:** Размер меняется во время выполнения (списки, `std::vector`).

### 2. Указатель vs. Ссылка:

*   **Указатель:** Хранит адрес **объекта**, можно менять (**адрес, на который указывает**), может быть `nullptr` (**в C++11 и новее**), разыменование `*`. **Нуждается в явном разыменовании для доступа к значению.**
*   **Ссылка:** Псевдоним **существующего объекта**, не меняется (**после инициализации всегда ссылается на один и тот же объект**), не может быть `nullptr`, **автоматическое разыменование**. **Должна быть инициализирована при объявлении.**

### 3. Виды указателей:

*   Обычные, void, на функции, константные (**указатель на константу, константный указатель**), на указатели, умные (`std::unique_ptr`, `std::shared_ptr`, `std::weak_ptr`).

### 4. Адрес переменной:

*   Оператор `&`, возвращает адрес в памяти **переменной**.

### 5. Выделение/освобождение памяти:

*   C/C++: `malloc`/`free`, `new`/`delete`, **`new[]`/`delete[]` для массивов**.
*   Java/Python: Автоматически (сборщик мусора). **C++ также имеет автоматическое управление памятью через RAII (Resource Acquisition Is Initialization), часто используемое с умными указателями.**

### 6. Разыменование:

*   Операция `*`, получение значения **объекта** по адресу указателя.

### 7. "Мусор" в динамической памяти:

*   Утечка из-за забытого `free`/`delete` **(в C++)** или потери указателя на выделенную память. **Приводит к нехватке ресурсов и потенциальным сбоям.**

### 8. Связанный список:

*   Последовательность узлов, каждый хранит данные и указатель на следующий **узел**.

### 9. Классификация связанных списков:

*   Односвязные, двусвязные, многосвязные.
*   Линейные, кольцевые.
*   Несортированные, отсортированные.
*   С/без головного узла **(фиктивного узла для упрощения операций)**.

### 10. Действия над списками:

*   Создание, добавление (в начало, конец, середину), удаление (по значению, индексу, узлу), поиск, просмотр, получение длины, очистка, разворот, слияние, сортировка.

### 11. Описание списка (C++):

*   `struct Node { DataType data; Node* next; };` **(где `DataType` - тип данных)**
*   `class LinkedList { Node* head; public: /*методы*/ };` **(указываем секцию public для доступа к методам)**

### 12. Стек, очередь:

*   **Стек:** LIFO (Last-In, First-Out). Операции: `push`, `pop`, `peek` (**top**).
*   **Очередь:** FIFO (First-In, First-Out). Операции: `enqueue` (**push, add**), `dequeue` (**pop, remove**), `peek` (**front**).

### 13. Операции над стеком:

*   `push` (добавить элемент на вершину), `pop` (удалить верхний элемент), `peek` (**top**) (посмотреть верхний элемент без удаления), `isEmpty`, **`isFull` (при реализации на массиве)**, `size`, `clear`.

### 14. Операции над очередью:

*   `enqueue` (добавить элемент в конец), `dequeue` (удалить элемент из начала), `peek` (**front**) (посмотреть элемент в начале без удаления), `isEmpty`, **`isFull` (при реализации на массиве с фиксированным размером)**, `size`, `clear`.

## Тема 17: Деревья

### 1. Дерево:

*   Иерархическая структура: корень, родитель, потомок, лист, **ветвь, уровень**.

### 2. Классификация деревьев (см. полную версию)** **(Примеры: бинарные деревья поиска, AVL-деревья, красно-черные деревья, B-деревья)**

### 3. Бинарное дерево:

*   У каждого узла не более 2 потомков (левый, правый).

### 4. Узел, потомок, предок, листья, корень:

*   Узел: элемент дерева.
*   Потомок: узел ниже по иерархии.
*   Предок: узел выше по иерархии.
*   Листья: узлы без потомков.
*   Корень: начальный узел.

### 5. Структура узла:

*   Данные, указатели на потомков (`left`, `right`), **указатель на `parent` (не всегда)**.

### 6. Обход дерева:

*   Прямой (корень, лево, право) **(preorder)**, симметричный (лево, корень, право) **(inorder)**, обратный (лево, право, корень) **(postorder)**.
*   Обход в ширину (по уровням) **(breadth-first search, BFS)**.

### 7. Динамические структуры данных:

*   Связный список, стек, очередь, дерево, граф, хэш-таблица, куча **(например, бинарная куча)**, **трие (префиксное дерево)**.

### 8. Преимущество дерева перед списком:

*   Более эффективный поиск/вставка/удаление **в отсортированных деревьях** (в среднем логарифмическая сложность).
*   Подходит для иерархических данных.

## Тема 18: Вектор

### 1. STL:

*   Стандартная библиотека шаблонов C++, контейнеры, итераторы, алгоритмы, **функциональные объекты (функторы)**.

### 2. Разновидности коллекций (см. полную версию)** **(Примеры: последовательные, ассоциативные, контейнерные адаптеры)**

### 3. Вектор (std::vector):

*   Динамический массив, быстрый доступ по индексу, автоматическое управление памятью, **эффективное добавление в конец**.

### 4. Описание вектора:

*   `std::vector<DataType> vectorName;`

### 5. Особенности обработки векторов:

*   Динамическое управление памятью, индексация, добавление/удаление (в конце эффективно, в начале/середине - нет), обход, копирование.

### 6. Доступ к элементу вектора:

*   `[]` (без проверки границ, **потенциально небезопасно**), `at()` (с проверкой границ, **генерирует исключение `std::out_of_range`**), `front()`, `back()`.

### 7. Последовательные контейнеры:

*   `vector`, `deque`, `list`, `forward_list`, `array`.

### 8. Итератор:

*   Объект для доступа к элементам контейнера, перемещение по контейнеру, **обобщенный способ доступа**.

### 9. Итерируемый объект:

*   Объект, поддерживающий итерацию, **предоставляет методы `begin()` и `end()`**, возвращает итератор.

### 10. Обход вектора с итератором:

*   Цикл `for` с `begin()`, `end()`, `++it`, range-based `for` **(`for (auto& element : vectorName)`)**.

## Тема 19: Множества

### 1. Определение множества:

*   Неупорядоченная **(в `std::unordered_set`)** или упорядоченная **(в `std::set`)** коллекция уникальных элементов.

### 2. Описание множества (C++):

*   `std::set<DataType>`, `std::unordered_set<DataType>`.

### 3. Базовый тип множества:

*   Тип данных, хранящихся в множестве (`DataType`).

### 4. Допустимый базовый тип:

*   Примитивные типы, строки, пользовательские классы **(должен быть определен оператор `<` для `std::set`, операторы `==` и `std::hash` для `std::unordered_set`)**.

### 5. Мощность множества, пустое множество:

*   Мощность: количество элементов **(размер)**.
*   Пустое множество: нет элементов, мощность 0.

### 6. Доступ к элементам множества:

*   Через итераторы (`begin`, `end`), `find()` **(возвращает итератор или `end()`, если не найдено)**, `contains()` **(C++20)**.

### 7. Операции над множествами:

*   `insert`, `erase`, `find`, `contains`, `size`, `empty`, `clear`.
*   Объединение, пересечение, разность **(можно реализовать с помощью алгоритмов STL, таких как `std::set_union`, `std::set_intersection`, `std::set_difference`)**.

### 8. Способы помещения элементов в множество:

*   Инициализация **(например, через список инициализации `{1, 2, 3}`)**, `insert()`, `emplace()` **(строит объект непосредственно в множестве)**, конструктор копирования.

### 9. Вывод множества целиком:

*   Перебор с итераторами или range-based `for`.

### 10. Вывод элементов множества:

*   Цикл `for` с итераторами, range-based `for`, `std::for_each`.

### 11. Множество и дубликаты:

*   Не может содержать одинаковые элементы **(при попытке вставки дубликата, множество не изменяется)**.

### 12. Множество и разные типы:

*   В C++ - только один тип **(шаблонный параметр)**, в Python - может **(но это создает неоднородное множество)**.

## Тема 20: Модули

### 1. Модульное программирование:

*   Разделение на независимые модули, скрытие реализации **(инкапсуляция)**, **улучшение читаемости и поддерживаемости кода**.

### 2. Модуль:

*   Отдельная **логически завершенная** часть программы, выполняющая **определенную** функцию.

### 3. Логические части модуля:

*   Интерфейс (что **модуль предоставляет**), реализация (как **это достигается**).

### 4. Заголовочный файл (`.h`, `.hpp`), исходный код (`.cpp`):

*   `.h` **(C)** / `.hpp` **(C++)**: Интерфейс (объявления **классов, функций, констант, типов**).
*   `.cpp`: Реализация (определения **функций, методов классов**).

### 5. Подключение модулей:

*   Директива `#include` **(для вставки содержимого файла)** в начале файла. **`<filename>` для системных/библиотечных, `"filename"` для пользовательских.**

### 6. Сфера действия переменных:

*   Модуль: файловая (глобальная **в пределах одного файла**), `static` - только внутри модуля **(ограниченная видимость в пределах файла)**.
*   Функция: локальная (только внутри функции).

### 7. Разделы модуля (заголовочного файла):

*   Защита от многократного включения **(`#ifndef`, `#define`, `#endif` или `#pragma once`)**, объявления, **возможно inline-реализация (для простых функций)**.

### 8. Организация модуля (C/C++):

*   `.h`/`.hpp`: Интерфейс.
*   `.cpp`: Реализация.
*   Подключение `#include`, компиляция **каждого `.cpp` файла отдельно**, линковка **результатов компиляции в исполняемый файл**.

### 9. Сборка программы:

*   Препроцессирование **(обработка директив `#include`, макросов)**, компиляция **(преобразование исходного кода в объектный код)**, компоновка **(объединение объектных файлов и библиотек в исполняемый файл)**.

### 10. Библиотечные функции при сборке:

*   Статические библиотеки (`.lib` в Windows, `.a` в Linux): код копируется в исполняемый файл **на этапе линковки**.
*   Динамические библиотеки (`.dll` в Windows, `.so` в Linux): линкер добавляет информацию **о необходимости загрузки библиотеки**, загрузка при запуске **программы**.

## Тема 21: Классы C++

### 1. ООП:

*   Инкапсуляция, наследование, полиморфизм, абстракция. **(Также композиция)**

### 2. Расширения C++ относительно C:

*   ООП, шаблоны, ссылки, исключения, STL, **перегрузка операторов, пространства имен, RTTI (Run-Time Type Information)**.

### 3. Класс:

*   Шаблон объекта, инкапсуляция, абстракция.
*   Объект - конкретная **экземпляр** класса **в памяти**.

### 4. Сообщение (ООП):

*   Запрос от объекта к другому **объекту** (вызов метода).

### 5. Событийно-управляемая модель:

*   Программа реагирует на события (нажатия кнопок и т.п.). **(Примеры: GUI-приложения, веб-разработка)**

### 6. Интерфейс:

*   Правила взаимодействия, публичная часть класса **(методы и данные, доступные извне)**.

### 7. Поля и методы класса:

*   Поля **(члены-данные)**: данные, **состояние объекта**.
*   Методы **(член-функции)**: действия, **поведение объекта**.

### 8. Классы и структуры:

*   `struct`: **public** по умолчанию, **часто используются для простых агрегатов данных (POD - Plain Old Data)**.
*   `class`: **private** по умолчанию, **предназначены для представления объектов с инкапсуляцией поведения и данных**.

### 9. Инкапсуляция, наследование, полиморфизм:

*   **(см. полную версию)** **Кратко: Инкапсуляция - сокрытие внутреннего состояния и реализации, доступ через интерфейс. Наследование - создание новых классов на основе существующих, повторное использование кода. Полиморфизм - возможность обрабатывать объекты разных классов единообразно.**

### 10. Структура объявления класса:

*   `class ClassName { public: /*...*/ protected: /*...*/ private: /*...*/ };`

### 11. Обращение к компонентам класса:

*   Внутри: по имени.
*   Снаружи: `.` (объект), `->` (указатель).
*   `private` члены недоступны напрямую извне **класса**.

### 12. Инициализация объектов:

*   По умолчанию **(если не определен конструктор, или определен конструктор по умолчанию)**, конструктор **(основной способ)**, список инициализации **(для инициализации членов в конструкторе)**.

### 13. Наследование и модификаторы доступа:

*   `public`, `protected`, `private` наследование **(определяют уровень доступа к унаследованным членам в производном классе)**.

### 14. Спецификаторы доступа:

*   `private` (только внутри класса), `public` (везде), `protected` (внутри класса и в наследниках).

### 15. Set/Get функции:

*   `set` (мутаторы): установить значение **закрытого поля**, `get` (аксессоры): прочитать значение **закрытого поля**.

### 16. Конструктор:

*   Метод **с именем класса**, инициализации объекта. **Может быть несколько (перегрузка).**

### 17. Деструктор:

*   Метод **с именем класса, начинающимся с `~`**, освобождения ресурсов объекта **при его уничтожении**.

### 18. Объявление класса в отдельном файле:

*   `.h`/`.hpp`: объявление, `.cpp`: реализация **методов**.
*   `#include` в другом файле для использования **класса**.

### 19. `new` и память:

*   `new` размещает объект в динамической памяти **(в куче)**, **возвращает указатель на созданный объект**. **Требует `delete` для освобождения памяти.**

### 20. Вызов методов из других методов:

*   Прямой вызов, через `this` **(указатель на текущий объект)**, виртуальные методы **(для реализации полиморфизма)**.

### 21. Доступ к закрытым членам класса:

*   Только методы класса **(включая конструкторы и деструктор)** и дружественные классы/функции **(объявленные с ключевым словом `friend`)**.
