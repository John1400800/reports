# Ответы по Алгоритмизации и Программированию (Ужатая версия)

### 1.a Этапы решения задач на ЭВМ

*   **Этапы решения задач на ЭВМ:** Постановка задачи, Разработка алгоритма, Программирование, Тестирование и отладка, Документирование, Эксплуатация и сопровождение.

### 1.b Технология программирования. Понятие программного обеспечения. Жизненный цикл программы.

*   **Технология программирования:** Методы, инструменты, процессы разработки ПО.
*   **Программное обеспечение:** Компьютерные программы, процедуры, правила, документация для компьютерных систем.
*   **Жизненный цикл программы (SDLC):** Этапы создания и развития ПО:
    *   **Каскадная:** Последовательные этапы.
    *   **Итерационная:** Циклы разработки.
    *   **Спиральная:** Риск-ориентированная, итерации + риски.
    *   **Agile:** Гибкая разработка, адаптация.

### 2.a Основы алгоритмизации. Свойства алгоритмов. Способы записи алгоритма. Теорема структуры. Базовые алгоритмические конструкции

*   **Основы алгоритмизации:** Принципы разработки алгоритмов.
*   **Свойства алгоритмов:** Дискретность, детерминированность, конечность, результативность, массовость.
*   **Способы записи алгоритма:** Словесный, графический, псевдокод, код.
*   **Теорема структуры:** Любой алгоритм реализуется через следование, ветвление, цикл.
*   **Базовые конструкции:** Следование, ветвление, цикл.

### 2.b Теоретические основы программирования. Технология программирования. Понятие программного обеспечения. Модели жизненного цикла ПО.

*   **Теоретические основы программирования:** Теория алгоритмов, вычислимости, языки, структуры данных.
*   **Технология программирования:** Методы, инструменты, процессы разработки ПО.
*   **Программное обеспечение:** Программы, процедуры, правила, документация.
*   **Модели жизненного цикла ПО:** Каскадная, итерационная, спиральная, Agile.

### 3.a Структура программы на языке высокого уровня. Правила записи текста программы. Этапы создания исполняемой программы

*   **Структура программы на языке высокого уровня (C++):**
    *   Препроцессорные директивы,
    *   Глобальные константы,
    *   Макросы и пространства имен,
    *   Объявления типов, структур, перечислений, классов,
    *   Шаблоны и концепты,
    *   Главная функция (main).
*   **Правила записи текста программы:** Синтаксис, регистр, идентификаторы, операторы, комментарии (Синтаксис языка, регистр символов (C++ регистрозависимый), именование (идентификаторы), операторы, комментарии для пояснений).
*   **Этапы создания исполняемой программы:** 1. Редактирование, 2. Препроцессирование, 3. Компиляция, 4. Компоновка, 5. Запуск (1. Редактирование (`.cpp`), 2. Препроцессирование, 3. Компиляция (`.o`/`.obj`), 4. Компоновка (`.exe`), 5. Запуск).

### 3.b Теоретические основы программирования. Место компилятора в программном обеспечении

*   **Теоретические основы программирования:** Фундаментальные концепции программирования.
*   **Место компилятора в ПО:** Ключевой инструмент: трансляция, проверка ошибок, оптимизация, создание исполняемых файлов (Ключевой инструмент для разработки ПО. Роль: Трансляция кода (исходный -> машинный/объектный код), Проверка ошибок, Оптимизация кода (опционально), Создание исполняемых файлов).

### 4.a Алфавит и лексемы языка Си. Представление текста в памяти компьютера. Кодовая страница

*   **Алфавит языка Си:** Буквы, цифры, спец. символы, пробельные символы (Буквы (латинские), цифры, специальные символы, пробельные символы).
*   **Лексемы языка Си:** Идентификаторы, ключевые слова, константы, операторы, разделители (Идентификаторы, ключевые слова, константы, операторы, разделители).
*   **Представление текста в памяти:** Числовые коды символов (кодировка) (Символы кодируются числовыми значениями согласно таблице кодировки).
*   **Кодовая страница:** Таблица символ - код (ASCII, Unicode) (Таблица соответствия между символами и их числовыми кодами. Примеры: ASCII, Unicode).

### 4.b Строковый ввод-вывод. Консольный вывод

*   **Строковый ввод-вывод:** Операции ввода/вывода строк (Операции для работы с текстовыми строками).
*   **Консольный вывод:** Вывод на экран (`std::cout`): строки, символы, числа, форматирование (`<iomanip>`) (Вывод текста на экран (стандартный поток вывода). В C++ используется `std::cout`. Вывод строк, символов, чисел. `std::cout` автоматически преобразует данные разных типов в текст. Форматирование вывода: Управление внешним видом выводимых данных с помощью манипуляторов из библиотеки `<iomanip>`).

### 5.a Операции языка Си. Общая характеристика. Логические операции языка Си. Арифметические операции языка Си. Математические функции языка Си. Битовые операции языка Си.

*   **Операции языка Си:** Действия над данными (Действия, выполняемые над данными (операндами)).
*   **Общая характеристика:** Действия над операндами, возвращают результат (Действия, выполняемые над данными (операндами)).
*   **Логические операции:** `&&`, `||`, `!` (`&&` (логическое И), `||` (логическое ИЛИ), `!` (логическое НЕ)).
*   **Арифметические операции:** `+`, `-`, `*`, `/`, `%`, `++`, `--` (`+` (сложение), `-` (вычитание), `*` (умножение), `/` (деление), `%` (остаток от деления), `++` (инкремент), `--` (декремент)).
*   **Математические функции:** `<cmath>` (`sqrt`, `pow`, `sin`, etc.) (Библиотека `<cmath>` предоставляет функции: `sqrt`, `pow`, `sin`, `cos`, `log` и другие).
*   **Битовые операции:** `&`, `|`, `^`, `~`, `<<`, `>>` (`&` (побитовое И), `|` (побитовое ИЛИ), `^` (побитовое исключающее ИЛИ), `~` (побитовое НЕ), `<<` (сдвиг влево), `>>` (сдвиг вправо)).

### 5.b Стандартные потоки ввода-вывода. Неформатный ввод-вывод. Форматный ввод-вывод. Форматирование с помощью манипуляторов

*   **Стандартные потоки:** `std::cin`, `std::cout`, `std::cerr`, `std::clog` (`std::cin` (стандартный ввод), `std::cout` (стандартный вывод), `std::cerr` (стандартный поток ошибок), `std::clog` (буферизованный поток ошибок)).
*   **Неформатный ввод-вывод:** Без формата (`<<`, `>>`, `get`, `put`, `read`, `write`) (Ввод и вывод данных как последовательности байтов, без явного указания формата).
*   **Форматный ввод-вывод:** С форматом (манипуляторы) (Ввод и вывод данных с заданным форматом).
*   **Форматирование манипуляторами:** `<iomanip>` (`std::endl`, `std::setw`, etc.) (Использование манипуляторов из `<iomanip>` для управления форматом вывода. Примеры: `std::endl`, `std::setw`, `std::setprecision`).

### 6.a Переменные и константы. Локальные и глобальные переменные. Время жизни и область видимости.

*   **Переменные:** Именованные области памяти для данных (Именованные области памяти для хранения данных, значения которых могут изменяться).
*   **Константы:** Неизменяемые значения (Значения, которые не изменяются в процессе выполнения программы).
*   **Локальные переменные:** Внутри блока, видимость - блок (Объявлены внутри блока кода, область видимости: Только внутри блока).
*   **Глобальные переменные:** Вне функций, видимость - файл (Объявлены вне функций, область видимости: Во всем файле).
*   **Время жизни:** Период существования переменной (Период времени, в течение которого переменная существует в памяти и может быть использована).
*   **Область видимости:** Доступность переменной (Часть кода программы, где переменная доступна для использования).

### 6.b Оптимизация кода.

*   **Оптимизация кода:** Улучшение производительности/ресурсов (Процесс улучшения кода для повышения его производительности или более эффективного использования ресурсов).

### 7.a Понятие идентификатора и ключевого слова. Правила создания идентификаторов в С++.

*   **Идентификатор:** Имя переменной, функции, класса (Имя, которое программист дает переменным, функциям, классам и другим элементам программы).
*   **Ключевое слово:** Зарезервированное слово языка (Зарезервированное слово языка программирования, имеющее специальное значение).
*   **Правила создания идентификаторов:** Буква или `_` в начале, буквы, цифры, `_` далее, регистрозависимы, не ключевое слово, без пробелов, спец. символов (Буква или `_` в начале, буквы, цифры, `_` в дальнейшем, Регистрозависимы, Не ключевое слово, Без пробелов, спец. символов).

### 7.b Не связанные с объектами расширения C++ относительно C. Новое в описании типов и переменных. Перегружаемые функции и функции с аргументами по умолчанию.

*   **Расширения C++ (не ООП):** Дополнения к C (Дополнения языка C++, не относящиеся к объектно-ориентированному программированию).
*   **Новое в типах и переменных:** `bool`, ссылки (`&`), `::`, пространства имен, `auto`, range-based for (Тип `bool`, ссылки (`&`), Оператор разрешения области видимости (`::`), Пространства имен (`namespace`), Автоматическое определение типа (`auto`), Цикл `for` на основе диапазона).
*   **Перегружаемые функции:** Функции с одинаковым именем, разными параметрами (Функции с одинаковым именем, но разными типами или количеством параметров).
*   **Функции с аргументами по умолчанию:** Параметры с заданными значениями (Параметры функций, которым можно задать значения по умолчанию).

### 8.a Данные и способы их организации. Стандартные типы данных языка Си. Спецификаторы типа данных языка Си, их назначение и порядок использования. Переименование типов в языке Си. Структурированные типы данных

*   **Данные и организация:** Простые, структурированные, динамические типы (Информация, обрабатываемая программой. Организация: простые переменные, массивы, структуры и другие структуры данных).
*   **Стандартные типы данных Си:** `int`, `char`, `float`, `double`, `void` + модификаторы (`int`, `char`, `float`, `double`, `void` + модификаторы: `signed`, `unsigned`, `short`, `long`).
*   **Спецификаторы типа данных Си:** `signed`, `unsigned`, `short`, `long`, `const`, `volatile` (`signed`, `unsigned`, `short`, `long`, `const`, `volatile`. Уточняют диапазон и представление данных).
*   **Переименование типов:** `typedef`, `using` (`typedef`, `using`. Создание синонимов для существующих типов данных).
*   **Структурированные типы данных:** Массивы, структуры, объединения, классы (Массивы, структуры (`struct`), объединения (`union`), классы (`class`)).

### 8.b Абстрактные типы данных. Обращение к компонентам класса. Статические члены. Защита элементов класса и атрибуты доступа. Конструкторы и деструкторы

*   **Абстрактные типы данных (ADT):** Тип данных по поведению (Типы данных, определяемые набором операций и свойствами, а не реализацией).
*   **Обращение к компонентам класса:** `.`, `->` (`.` (точка), `->` (стрелка). Для доступа к членам объекта класса).
*   **Статические члены класса:** Принадлежат классу (Переменные и функции, принадлежащие самому классу, а не его отдельным объектам).
*   **Защита элементов класса:** `private`, `protected`, `public` (`private`, `protected`, `public`. Механизмы управления доступом к членам класса).
*   **Конструкторы и деструкторы:** Инициализация/уничтожение объектов (Конструкторы - инициализация объектов, Деструкторы - освобождение ресурсов объектов).

### 9.a Понятие оператора. Простые операторы языка Си. Организация ввода/вывода данных. Базовые конструкции языка Си.

*   **Оператор:** Символ/слово, обозначающее действие (Символ или ключевое слово, обозначающее действие, которое необходимо выполнить в программе).
*   **Простые операторы Си:** Присваивание, арифметические, сравнения, логические, битовые, `sizeof`, `,`, `?:` (Присваивание, арифметические, сравнения, логические, битовые, `sizeof`, `,`, `?:`).
*   **Организация ввода/вывода:** Стандартные потоки, `scanf`, `printf`, `cin`, `cout` (Стандартные потоки (`stdin`, `stdout`, `stderr`), функции `scanf`, `printf`, `cin`, `cout`).
*   **Базовые конструкции Си:** Следование, ветвление, циклы (Следование, ветвление (`if`, `if-else`, `switch`), циклы (`for`, `while`, `do-while`)).

### 9.b Потоки ввода-вывода. Иерархия классов ввода-вывода. Основные функции. Форматированный и неформатированный ввод-вывод. Функции.

*   **Потоки ввода-вывода:** Последовательности байтов (Абстракции, представляющие собой последовательности байтов).
*   **Иерархия классов ввода-вывода:** `std::ios_base`, `std::ios`, `std::istream`, `std::ostream`, `std::iostream`, `std::fstream`, `std::sstream` (Классы для работы с потоками ввода-вывода организованы в иерархию наследования).
*   **Основные функции:** `<<`, `>>`, `get`, `getline`, `read`, `write`, `put`, `seek`, `tell`, `eof`, `fail`, `bad`, `good`, `clear` (`<<`, `>>`, `get`, `getline`, `read`, `write`, `put`, `seek`, `tell`, `eof`, `fail`, `bad`, `good`, `clear`).
*   **Форматированный ввод-вывод:** Манипуляторы (Использование манипуляторов для управления форматом).
*   **Неформатированный ввод-вывод:** Побайтовый (Побайтовый ввод-вывод, без форматирования).
*   **Функции:** Методы классов потоков (Методы классов потоков).

### 10.a Условный оператор. Условный оператор множественного выбора. Графическое отображение и оператор

*   **Условный оператор:** `if`, `if-else` (выбор 2 ветвей). Блок-схема `if`, `if-else`: ромб - ветви ( `if`, `if-else` (выбор 2 ветвей). Блок-схема `if`: Ромб - "Да" ветвь. Блок-схема `if-else`: Ромб - "Да"/"Нет" ветви).
*   **Условный оператор множественного выбора:** `switch` (выбор из многих). Блок-схема `switch`: многоугольник - `case` - `default` (`switch` (выбор из многих). Блок-схема `switch`: Многоугольник - `case` блоки - `default`).

### 10.b set – функции и get – функции классов

*   **Set-функции (сеттеры):** Установка значений `private`/`protected` полей (Методы класса, предназначенные для установки значений `private`/`protected` полей класса).
*   **Get-функции (геттеры):** Получение значений `private`/`protected` полей (Методы класса, предназначенные для получения значений `private`/`protected` полей класса).
*   **Назначение:** Контроль доступа, инкапсуляция (Обеспечение контролируемого доступа к данным класса, инкапсуляция).

### 11.a Понятие цикла с предусловием. Графическое отображение

*   **Цикл с предусловием:** `while`. Условие перед телом (Цикл `while`. Условие **перед** телом). Блок-схема: ромб (условие) - "Да" -> действия - возврат; "Нет" -> выход (Блок-схема: Ромб (условие) - "Да" -> блок действий - возврат; "Нет" -> выход).

### 11.b Вложенные циклы. Операторы передачи управления

*   **Вложенные циклы:** Цикл внутри цикла (Цикл внутри другого цикла).
*   **Операторы передачи управления:** `break`, `continue`, `goto`, `return` (`break`, `continue`, `goto`, `return`).

### 12.a Понятие цикла с постусловием, графическое отображение

*   **Цикл с постусловием:** `do-while`. Условие после тела (Цикл `do-while`. Условие **после** телом цикла). Блок-схема: действия - ромб (условие) - "Да" -> возврат; "Нет" -> выход (Блок-схема: Блок действий - Ромб (условие) - "Да" -> возврат; "Нет" -> выход).

### 12.b Вложенные циклы. Операторы передачи управления. Организация пользовательского меню

*   **Вложенные циклы:** Циклы внутри циклов.
*   **Операторы передачи управления:** `break`, `continue`, `goto`, `return`.
*   **Пользовательское меню:** `do-while`, `cout` меню, `cin` выбор, `switch`/`if-else`, `break`, условие выхода (`do-while`, `cout` меню, `cin` выбор, `switch`/`if-else`, `break`, условие выхода).

### 13.a Понятие цикла с параметром, графическое отображение

*   **Цикл с параметром:** `for`. Счетчик итераций (Цикл `for`. Счетчик итераций). Блок-схема: шестиугольник (параметры) - ромб (условие) - "Да" -> действия - изменение параметра - возврат; "Нет" -> выход (Блок-схема: Шестиугольник (параметры) - Ромб (условие) - "Да" -> блок действий - изменение параметра - возврат; "Нет" -> выход).

### 13.b Вложенные циклы. Операторы передачи управления. Реализация обхода коллекции.

*   **Вложенные циклы:** Циклы внутри циклов.
*   **Операторы передачи управления:** `break`, `continue`, `goto`, `return`.
*   **Обход коллекции:** Циклы для доступа к элементам массива, вектора, списка (Циклы для доступа к элементам массива, вектора, списка).

### 14.a Понятие массива. Порядок объявления и инициализации массивов.

*   **Массив:** Коллекция однотипных элементов, непрерывная память, доступ по индексу (Упорядоченная коллекция однотипных элементов, непрерывная память, доступ по индексу).
*   **Объявление массива:** `тип имя_массива[размер];` (`тип имя_массива[размер];` (одномерный)).
*   **Инициализация массивов:** При объявлении (`{...}`), поэлементно, циклически (При объявлении (`{...}`), поэлементно, циклически).

### 14.b Особенности обработки массивов (ввод/вывод и др. ) Динамические одномерные массивы.

*   **Особенности обработки массивов:** Ввод/вывод поэлементно, передача в функцию как указатель, копирование поэлементно (Ввод/вывод: Поэлементно, циклы. Передача в функцию: Как указатель, размер отдельно. Копирование: Поэлементно).
*   **Динамические одномерные массивы:** Размер во время выполнения, выделение `new[]`/`malloc`, освобождение `delete[]`/`free` (Размер во время выполнения. Выделение: `new[]` (C++), `malloc` (C). Освобождение: `delete[]` (C++), `free` (C)).

### 15.a Понятие указателя. Порядок объявления и инициализации указателей. Операции с указателями

*   **Указатель:** Адрес памяти переменной (Адрес памяти переменной).
*   **Объявление указателя:** `тип_данных *имя_указателя;` (`тип_данных *имя_указателя;`).
*   **Инициализация:** `&переменная`, `nullptr`/`NULL`, `new` (`&переменная`, `nullptr`/`NULL`, `new`).
*   **Операции с указателями:** `&`, `*`, арифметика, сравнение (`&`, `*`, арифметика, сравнение).

### 15.b Динамические структуры данных. Особенности обработки связанного списка.  Особенности обработки двусвязанного списка.

*   **Динамические структуры данных:** Размер меняется во время выполнения (Размер меняется во время выполнения).
*   **Связный список:** Узлы + `next` указатель, динамическая память, последовательный доступ, эффективная вставка/удаление (Узлы + `next` указатель, динамическая память, последовательный доступ, эффективная вставка/удаление в середине).
*   **Двусвязный список:** Узлы + `next`, `prev` указатели, двунаправленный обход, проще вставка/удаление (Узлы + `next`, `prev` указатели, двунаправленный обход, проще вставка/удаление, больше памяти).

### 16.a Связь между массивами и указателями. Динамические массивы. Порядок объявления. Функции и массивы. Порядок передачи массивов в функцию

*   **Связь массивов и указателей:** Имя массива - указатель на первый элемент (Имя массива - **указатель** на первый элемент).
*   **Динамические массивы:** Размер во время выполнения, `new[]`/`delete[]`, `malloc`/`free` (Размер во время выполнения, `new[]`/`delete[]`, `malloc`/`free`).
*   **Объявление динамических массивов:** `new[]`, `malloc` (`new[]`, `malloc`).
*   **Функции и массивы:** Функции принимают массивы как указатели (Функции принимают массивы как указатели).
*   **Передача массивов в функцию:** Указатель, размер, изменения влияют на оригинал (Указатель, размер отдельно, изменения в функции влияют на оригинал).

### 16.b Вектор. Понятие вектора. Формат описания. Основные методы Вектора. Итераторы

*   **Вектор (std::vector):** Динамический массив STL (Динамический массив STL).
*   **Понятие вектора:** Динамический размер, быстрый доступ по индексу (Динамический размер, быстрый доступ по индексу).
*   **Формат описания:** `#include <vector>`, `std::vector<тип_данных> имя_вектора;` (`#include <vector>`, `std::vector<тип_данных> имя_вектора;`).
*   **Основные методы:** `push_back`, `pop_back`, `insert`, `erase`, `size`, `at`, `[]` (`push_back`, `pop_back`, `insert`, `erase`, `size`, `at`, `[]`).
*   **Итераторы:** `begin()`, `end()`, для обхода (`begin()`, `end()`, для обхода).

### 17.a Понятие структурированного типа данных. Строки символов и порядок их хранения.

*   **Структурированный тип данных:** Объединение элементов данных (Объединение нескольких элементов данных).
*   **Строки символов:** Текст, C-строки (`char[]`), `std::string` (Текст, C-строки (`char[]`), `std::string`).
*   **Порядок хранения строк:** C-строки: `char[]`, `\0` в конце; `std::string`: динамически (C-строки: `char[]`, последовательно, `\0` в конце. `std::string`: Динамически, детали скрыты).

### 17.b Символьные и строковые функции языка Си

*   **Символьные функции (`<ctype.h>`):** Проверка типа, преобразование регистра (Проверка типа, преобразование регистра).
*   **Строковые функции (`<string.h>`):** Копирование, конкатенация, сравнение, поиск, длина, преобразование в число, форматирование (Копирование, конкатенация, сравнение, поиск, длина, преобразование в число, форматирование).

### 18.a Понятие структурированного типа данных. Определение структур данных, их инициализация и особенности хранения. Доступ к элементам структуры. Функции и структуры. Порядок передачи структур в функцию.

*   **Структурированный тип данных:** Объединение разнотипных элементов (Объединение разнотипных элементов).
*   **Определение структур:** `struct ИмяСтруктуры { /*поля*/ };` (`struct ИмяСтруктуры { /*поля*/ };`).
*   **Инициализация структур:** `{}`, поэлементно (`{}`, поэлементно).
*   **Хранение структур:** Последовательно, выравнивание (Последовательно, выравнивание).
*   **Доступ к элементам:** `.`, `->` (`.`, `->`).
*   **Функции и структуры:** Функции принимают/возвращают структуры (Функции принимают/возвращают структуры).
*   **Передача структур в функцию:** По значению, по указателю, по ссылке (По значению, по указателю, по ссылке).

### 18.b Множества. Множества как вычислительные структуры: определение, описание и ограничения. Операции над множествами. Итераторы

*   **Множества:** Коллекция **уникальных** элементов, `std::set`, `std::unordered_set` (Коллекция **уникальных** элементов, `std::set`, `std::unordered_set`).
*   **Множества как вычислительные структуры:** Уникальность, быстрый поиск, вставка, удаление. Ограничения: уникальность, сравнимость, один тип, нет доступа по индексу (Уникальность, быстрый поиск, вставка, удаление. Ограничения: Уникальность, сравнимость, один тип данных, нет доступа по индексу).
*   **Операции:** `insert`, `erase`, `find`, `contains`, `size`, `empty`, `clear`, объединение, пересечение, разность (`insert`, `erase`, `find`, `contains`, `size`, `empty`, `clear`, объединение, пересечение, разность).
*   **Итераторы:** `begin()`, `end()` (`begin()`, `end()`).

### 19.a Понятие подпрограммы. Понятие функции. Ее назначение, порядок объявления и описания. Понятие и назначение прототипа пользовательской функции.

*   **Подпрограмма:** Именованный блок кода (Именованный блок кода для задачи).
*   **Функция:** Вид подпрограммы, имя, параметры, возврат (Вид подпрограммы, имя, параметры, возврат).
*   **Назначение функции:** Модульность, повторное использование, упрощение (Модульность, повторное использование, упрощение).
*   **Объявление функции (прототип):** Интерфейс, без тела (Интерфейс, без тела, `;` в конце).
*   **Описание функции (определение):** Объявление + тело (Объявление + тело `{}`).
*   **Прототип функции:** Объявление, информирует компилятор (Объявление, информирует компилятор, ранняя проверка ошибок).

### 19.b Модульное программирование средствами языков C и C++

*   **Модульное программирование:** Разделение на модули, независимость (Разделение на модули, независимость).
*   **Реализация в C/C++:** `.h`/`.hpp`, `.cpp`, `#include`, пространства имен, `static` (`.h`/`.hpp` (интерфейс), `.cpp` (реализация), `#include`, пространства имен, `static`).
*   **Преимущества:** Организация, повторное использование, отладка (Организация, повторное использование, отладка, сопровождение).

### 20.a Передача параметров в функцию (по значению, по адресу, по ссылке). Возвращаемые параметры функции. Назначение возвращаемого значения

*   **Передача параметров в функцию:** По значению (копия), по адресу (указатель), по ссылке (псевдоним) (По значению (копия), По адресу (указатель, оригинал), По ссылке (псевдоним, оригинал)).
*   **Возвращаемое значение:** Результат функции (Результат работы функции).
*   **Назначение:** Передача результата, индикация статуса (Передача результата, индикация статуса).

### 20.b Потоки ввода-вывода. Иерархия классов ввода-вывода. Основные функции. Форматированный и неформатированный ввод-вывод. Функции.

*   **Потоки ввода-вывода:** Последовательности байтов (Последовательности байтов для передачи данных).
*   **Иерархия классов:** `std::ios_base`, `std::ios`, `std::istream`, `std::ostream`, `std::iostream`, `std::fstream`, `std::sstream` (`std::ios_base`, `std::ios`, `std::istream`, `std::ostream`, `std::iostream`, `std::fstream`, `std::sstream`).
*   **Основные функции:** `<<`, `>>`, `get`, `getline`, `read`, `write`, `put`, `seek`, `tell`, `eof` (`<<`, `>>`, `get`, `getline`, `read`, `write`, `put`, `seek`, `tell`, `eof`, etc.).
*   **Форматированный ввод-вывод:** Манипуляторы (Манипуляторы).
*   **Неформатированный ввод-вывод:** Побайтовый (Побайтовый).
*   **Функции:** Методы классов потоков (Методы классов потоков).

### 21.a Понятие подпрограммы. Понятие функции. Рекурсивные функции. Понятие итеративного процесса

*   **Подпрограмма:** Именованный блок кода (Именованный блок кода для задачи).
*   **Функция:** Вид подпрограммы (Вид подпрограммы, имя, параметры, возврат).
*   **Рекурсивные функции:** Вызывают себя (Вызывают сами себя, нужен базовый случай).
*   **Итеративный процесс:** Повторение блока кода (цикл) (Повторение блока кода (цикл)).

### 21.b Динамические структуры данных. Понятие стека. Особенности инициализации и обработки стека.

*   **Динамические структуры данных:** Размер меняется во время выполнения (Размер меняется во время выполнения).
*   **Стек:** LIFO, вершина (LIFO, вершина).
*   **Инициализация стека:** Пустой, массив/список, `std::stack` (Пустой, массив/список, `std::stack`).
*   **Операции стека:** `push`, `pop`, `top`, `empty`, `size` (`push`, `pop`, `top`, `empty`, `size`).
*   **Особенности обработки:** LIFO, ограниченный доступ (LIFO, ограниченный доступ, переполнение/опустошение).

### 22.a Понятие файлов данных и потоков и их классификация. Типы файлов данных и ключи доступа. Функции для работы с файлами последовательного доступа. Функции для работы с файлами прямого доступа

*   **Файлы данных:** Постоянное хранение (Постоянное хранение на носителе).
*   **Потоки:** Последовательности байтов для I/O файлов (Последовательности байтов для I/O файлов).
*   **Классификация файлов:** Текстовые, бинарные (Текстовые, бинарные).
*   **Типы файлов и ключи доступа:** Режимы `"r"`, `"w"`, `"a"`, etc. (Режимы `"r"`, `"w"`, `"a"`, `"r+"`, etc.).
*   **Функции последовательного доступа:** `fopen`, `fclose`, `fread`, `fwrite`, etc. (`fopen`, `fclose`, `fread`, `fwrite`, `fscanf`, `fprintf`, `fgetc`, `fputc`, `fgets`, `fputs`, `feof`).
*   **Функции прямого доступа:** `fseek`, `ftell`, `fread`, `fwrite` (`fseek`, `ftell`, `fread`, `fwrite`).

### 22.b Концепция объектно-ориентированного программирования. Понятие объекта и фундаментальные характеристики ООП (инкапсуляция, наследование, полиморфизм).

*   **ООП:** Парадигма программирования на объектах (Парадигма программирования на объектах).
*   **Объект:** Экземпляр класса, состояние + поведение (Экземпляр класса, состояние + поведение).
*   **Фундаментальные характеристики ООП:** Инкапсуляция, Наследование, Полиморфизм, Абстракция (Инкапсуляция, Наследование, Полиморфизм, Абстракция).

### 23.a Постановка задачи сортировки данных. Внутренняя и внешняя сортировки. Алгоритмы решения задач внутренней сортировки

*   **Задача сортировки данных:** Упорядочение элементов (Упорядочение элементов коллекции).
*   **Внутренняя сортировка:** В ОП (В ОП).
*   **Внешняя сортировка:** На дисках (На внешних носителях (дисках)).
*   **Алгоритмы внутренней сортировки:** Прямые `O(n^2)`, Быстрые `O(n log n)` (Прямые: `O(n^2)`, Быстрые: `O(n log n)`).

### 23.b Сложность алгоритмов. Ускоренные алгоритмы решения задач внутренней сортировки

*   **Сложность алгоритмов:** Мера ресурсов (время, память), O-нотация (Мера ресурсов (время, память), O-нотация).
*   **Классы сложности:** `O(1)`, `O(log n)`, `O(n)`, `O(n log n)`, `O(n^2)`, `O(2^n)`, `O(n!)` (`O(1)`, `O(log n)`, `O(n)`, `O(n log n)`, `O(n^2)`, `O(2^n)`, `O(n!)`).
*   **Ускоренные алгоритмы:** MergeSort, QuickSort, HeapSort (`O(n log n)`) (MergeSort, QuickSort, HeapSort (`O(n log n)` средняя сложность)).

### 24.a Алгоритмы поиска информации

*   **Алгоритмы поиска информации:** Нахождение информации в данных (Нахождение информации в данных).
*   **Классификация по структуре данных:** Массивы, списки, деревья, графы, хеш-таблицы (Массивы, списки, деревья, графы, хеш-таблицы).
*   **Алгоритмы поиска:** Линейный, бинарный, интерполяционный, хэш, по индексу, по дереву, строковый (Линейный, бинарный, интерполяционный, хэш, по индексу, по дереву, строковый).

### 24.b Понятие Бинарное дерево дерева. Классификация деревьев.

*   **Бинарное дерево:** Узел до 2 потомков (Узел не более 2 потомков).
*   **Классификация деревьев:** Потомки, Упорядоченность, Балансировка, Специальные типы (Потомки, Упорядоченность, Балансировка, Специальные типы).

### 25.a Файловый ввод-вывод. Классы файлового ввода-вывода. Организация доступа к файлу. Основные функции.

*   **Файловый ввод-вывод:** Чтение/запись файлов (Чтение/запись в файлы).
*   **Классы файлового I/O:** `std::ifstream`, `std::ofstream`, `std::fstream` (`std::ifstream`, `std::ofstream`, `std::fstream` (`<fstream>`)).
*   **Организация доступа:** Последовательный, прямой (Последовательный, прямой).
*   **Основные функции:** `open`, `close`, `<<`, `>>`, `getline`, `read`, `write`, `put`, `seek`, `tell`, `eof` (`open`, `close`, `<<`, `>>`, `getline`, `read`, `write`, `put`, `seek`, `tell`, `eof`, etc.).

### 25.b Конструкторы и деструкторы. Инициализация объектов. Автоматические, динамические и статические объекты

*   **Конструкторы:** Инициализация объектов (Инициализация объектов, имя класса, перегрузка).
*   **Деструкторы:** Освобождение ресурсов объектов (Освобождение ресурсов объектов, `~ИмяКласса()`).
*   **Инициализация объектов:** По умолчанию, конструкторы, список инициализации (По умолчанию, конструкторы, список инициализации).
*   **Автоматические объекты:** В стеке, автоматическое время жизни (В стеке, автоматическое время жизни).
*   **Динамические объекты:** В куче, `new`/`delete` (В куче, `new`/`delete`, ручное управление).
*   **Статические объекты:** Локальные, глобальные, время жизни - программа (Локальные, глобальные, время жизни - программа).


*   1.a     Этапы решения задач на ЭВМ
*   1.b     Технология программирования. Понятие программного обеспечения. Жизненный цикл программы.
*   2.a     Основы алгоритмизации. Свойства алгоритмов. Способы записи алгоритма. Теорема структуры. Базовые алгоритмические конструкции
*   2.b     Теоретические основы программирования. Технология программирования. Понятие программного обеспечения. Модели жизненного цикла ПО.
*   3.a     Структура программы на языке высокого уровня. Правила записи текста программы. Этапы создания исполняемой программы
*   3.b     Теоретические основы программирования. Место компилятора в программном обеспечении
*   4.a     Алфавит и лексемы языка Си. Представление текста в памяти компьютера. Кодовая страница
*   4.b     Строковый ввод-вывод. Консольный вывод
*   5.a     Операции языка Си. Общая характеристика. Логические операции языка Си. Арифметические операции языка Си. Математические функции языка Си. Битовые операции языка Си.
*   5.b     Стандартные потоки ввода-вывода. Неформатный ввод-вывод. Форматный ввод-вывод. Форматирование с помощью манипуляторов
*   6.a     Переменные и константы. Локальные и глобальные переменные. Время жизни и область видимости.
*   6 b     Оптимизация кода.
*   7.a     Понятие идентификатора и ключевого слова. Правила создания идентификаторов в С++.
*   7.b     Не связанные с объектами расширения C++ относительно C. Новое в описании типов и переменных. Перегружаемые функции и функции с аргументами по умолчанию.
*   8.a     Данные и способы их организации. Стандартные типы данных языка Си. Спецификаторы типа данных языка Си, их назначение и порядок использования. Переименование типов в языке Си. Структурированные типы данных
*   8.b     Абстрактные типы данных. Обращение к компонентам класса. Статические члены. Защита элементов класса и атрибуты доступа. Конструкторы и деструкторы
*   9.a     Понятие оператора. Простые операторы языка Си. Организация ввода/вывода данных. Базовые конструкции языка Си.
*   9.b     Потоки ввода-вывода. Иерархия классов ввода-вывода. Основные функции. Форматированный и неформатированный ввод-вывод. Функции.
*   10.a    Условный оператор. Условный оператор множественного выбора. Графическое отображение и оператор
*   10.b    set – функции и get – функции классов
*   11.a    Понятие цикла с предусловием. Графическое отображение
*   11.b    Вложенные циклы. Операторы передачи управления
*   12.a    Понятие цикла с постусловием, графическое отображение
*   12.b    Вложенные циклы. Операторы передачи управления. Организация пользовательского меню
*   13.a    Понятие цикла с параметром, графическое отображение
*   13.b    Вложенные циклы. Операторы передачи управления. Реализация обхода коллекции.
*   14.a    Понятие массива. Порядок объявления и инициализации массивов.
*   14.b    Особенности обработки массивов (ввод/вывод и др. ) Динамические одномерные массивы.
*   15.a    Понятие указателя. Порядок объявления и инициализации указателей. Операции с указателями
*   15.b    Динамические структуры данных. Особенности обработки связанного списка.  Особенности обработки двусвязанного списка.
*   16.a    Связь между массивами и указателями. Динамические массивы. Порядок объявления. Функции и массивы. Порядок передачи массивов в функцию
*   16.b    Вектор. Понятие вектора. Формат описания. Основные методы Вектора. Итераторы
*   17.a    Понятие структурированного типа данных. Строки символов и порядок их хранения.
*   17.b    Символьные и строковые функции языка Си
*   18.a    Понятие структурированного типа данных. Определение структур данных, их инициализация и особенности хранения. Доступ к элементам структуры. Функции и структуры. Порядок передачи структур в функцию.
*   18.b    Множества. Множества как вычислительные структуры: определение, описание и ограничения. Операции над множествами. Итераторы
*   19.a    Понятие подпрограммы. Понятие функции. Ее назначение, порядок объявления и описания. Понятие и назначение прототипа пользовательской функции.
*   19.b    Модульное программирование средствами языков C и C++
*   20.a    Передача параметров в функцию (по значению, по адресу, по ссылке). Возвращаемые параметры функции. Назначение возвращаемого значения
*   20.b    Потоки ввода-вывода. Иерархия классов ввода-вывода. Основные функции. Форматированный и неформатированный ввод-вывод. Функции.
*   21.a    Понятие подпрограммы. Понятие функции. Рекурсивные функции. Понятие итеративного процесса
*   21.b    Динамические структуры данных. Понятие стека. Особенности инициализации и обработки стека.
*   22.a    Понятие файлов данных и потоков и их классификация. Типы файлов данных и ключи доступа. Функции для работы с файлами последовательного доступа. Функции для работы с файлами прямого доступа
*   22.b    Концепция объектно-ориентированного программирования. Понятие объекта и фундаментальные характеристики ООП (инкапсуляция, наследование, полиморфизм).
*   23.a    Постановка задачи сортировки данных. Внутренняя и внешняя сортировки. Алгоритмы решения задач внутренней сортировки
*   23.b    Сложность алгоритмов. Ускоренные алгоритмы решения задач внутренней сортировки
*   24.a    Алгоритмы поиска информации
*   24.b    Понятие Бинарное дерево дерева. Классификация деревьев.
*   25.a    Файловый ввод-вывод. Классы файлового ввода-вывода. Организация доступа к файлу. Основные функции.
*   25.b    Конструкторы и деструкторы. Инициализация объектов. Автоматические, динамические и статические объекты

